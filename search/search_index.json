{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to docs of Exit EMBA report project.","text":""},{"location":"app/backend/readme/","title":"Readme","text":"<p>In this module you will find classes that are used for: - processing raw table and converting it to the standard format (raw_data_processor.py) - extracting data for plots from a processed table (data_extractors) - plotting based on extracted data (plotter.py)</p>"},{"location":"app/sections/readme/","title":"Readme","text":"<p>In this module you will find methods that are used for rendering sections in the main web page.</p>"},{"location":"eda/readme/","title":"Readme","text":"<p>In this section you will find some draft solutions. The main code of the app is located in the app dir.</p>"},{"location":"references/backend/","title":"App backend","text":""},{"location":"references/backend/#app.backend.data_extractors","title":"<code>app.backend.data_extractors</code>","text":"<p>Add classes of data extractors for different surveys/tables/programs here.</p>"},{"location":"references/backend/#app.backend.data_extractors.ExitEmbaExtractor","title":"<code>ExitEmbaExtractor</code>","text":"<p>Extracts and organizes data from an Excel table for plotting purposes. This class reads a structured .xlsx file and provides methods to extract and preprocess data for generating various analytical plots (e.g., distribution charts, trends) and calculating some metrics.</p> <p>Methods:</p> Name Description <code>get_age_distr</code> <p>Returns respondent counts by age group.</p> <code>get_industry_distr</code> <p>Returns distribution of respondents by industry.</p> <code>get_job_distr</code> <p>Returns counts of selected job functions.</p> <code>get_overall_csi</code> <p>Extracts average CSI scores for key program components.</p> <code>calulate_csi</code> <p>Computes overall CSI score from component data.</p> <code>get_group_csi</code> <p>Extract CSI data for various program evaluation blocks.</p> <code>get_pilos</code> <p>Aggregates counts of ratings for program learning outcomes.</p> <code>get_top_lectors</code> <p>Counts and ranks lecturer selections.</p> <code>get_collaborators</code> <p>Summarizes alumni collaboration preferences.</p> <code>get_programs_nps, get_industry_nps</code> <p>Return NPS data for programs and industries.</p> Source code in <code>src/app/backend/data_extractors.py</code> <pre><code>class ExitEmbaExtractor:\n    \"\"\"Extracts and organizes data from an Excel table for plotting purposes.\n    This class reads a structured .xlsx file and provides methods to extract\n    and preprocess data for generating various analytical plots (e.g., distribution charts, trends)\n    and calculating some metrics.\n\n    Methods:\n        get_age_distr: Returns respondent counts by age group.\n        get_industry_distr: Returns distribution of respondents by industry.\n        get_job_distr: Returns counts of selected job functions.\n        get_overall_csi: Extracts average CSI scores for key program components.\n        calulate_csi: Computes overall CSI score from component data.\n        get_basic_csi, get_design_csi, get_intern_modules_csi, get_support_csi,\n        get_group_csi: Extract CSI data for various program evaluation blocks.\n        get_pilos: Aggregates counts of ratings for program learning outcomes.\n        get_top_lectors: Counts and ranks lecturer selections.\n        get_collaborators: Summarizes alumni collaboration preferences.\n        get_programs_nps, get_industry_nps: Return NPS data for programs and industries.\n    \"\"\"\n\n    def __init__(self, table_path: str | IO):\n        \"\"\"Initialize an extractor object\n\n        Args:\n            table_path (str | IO): string with a path to a structured Excel tables or a file-like object.\n        \"\"\"\n        self.df = pd.read_excel(table_path)\n\n    # below are methods for extracting data, used in piecharts\n    def get_age_distr(self, age_Qind: int = 15) -&gt; Dict[str, int]:\n        \"\"\"Returns the distribution of respondents by age group.\n        This method extracts responses from a specific question in the table.\n\n        Args:\n            age_Qind (int, optional): The index of the question containing age group information. Defaults to 15.\n\n        Returns:\n            Dict[str, int]: A dictionary mapping age group labels (e.g., \"25-34\")\n            to the number of respondents in each group.\n        \"\"\"\n        age_groups = {\n            1.0: \"18-24\",\n            2.0: \"25-34\",\n            3.0: \"35-44\",\n            4.0: \"45-54\",\n            5.0: \"55+\",\n        }\n        age_counts = self.df[f\"Q{age_Qind} \ud83d\udd34  \u0423\u043a\u0430\u0436\u0438\u0442\u0435 \u0432\u0430\u0448  \u0432\u043e\u0437\u0440\u0430\u0441\u0442\"].value_counts()\n        age_counts.index = age_counts.index.to_series().map(age_groups)\n        age_counts = age_counts.to_dict()\n        return age_counts\n\n    def get_industry_distr(self, industry_Qind: int = 14) -&gt; Dict[str, int]:\n        \"\"\"Returns the distribution of respondents by industry.\n        This method extracts responses from a specific question in the table.\n\n        Args:\n            industry_Qind (int, optional): Index of the industry question. Defaults to 14.\n\n        Returns:\n            Dict[str, int]: Industry labels mapped to respondent counts.\n        \"\"\"\n        industry_codes = {\n            1: \"\u0421\u0440\u0435\u0434\u0441\u0442\u0432\u0430 \u043c\u0430\u0441\u0441\u043e\u0432\u043e\u0439 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0438 \u0440\u0430\u0437\u0432\u043b\u0435\u0447\u0435\u043d\u0438\u044f\",\n            2: \"\u0417\u0434\u0440\u0430\u0432\u043e\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435\",\n            3: \"\u041e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435\",\n            4: \"\u041d\u0435\u043a\u043e\u043c\u043c\u0435\u0440\u0447\u0435\u0441\u043a\u0438\u0435 \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u0430\u0446\u0438\u0438, \u043d\u0435\u043f\u0440\u0430\u0432\u0438\u0442\u0435\u043b\u044c\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0435 \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u0430\u0446\u0438\u0438\",\n            5: \"\u0413\u043e\u0441\u0443\u0434\u0430\u0440\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0439 \u0441\u0435\u043a\u0442\u043e\u0440\",\n            6: \"\u041a\u043e\u043d\u0441\u0430\u043b\u0442\u0438\u043d\u0433\",\n            7: \"\u041d\u0435\u0434\u0432\u0438\u0436\u0438\u043c\u043e\u0441\u0442\u044c\",\n            8: \"\u0424\u0438\u043d\u0430\u043d\u0441\u044b\",\n            9: \"\u0422\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438\",\n            10: \"\u041e\u0442\u0435\u043b\u0438, \u0420\u0435\u0441\u0442\u043e\u0440\u0430\u043d\u044b, \u041a\u0435\u0439\u0442\u0435\u0440\u0438\u043d\u0433\",\n            11: \"\u041b\u043e\u0433\u0438\u0441\u0442\u0438\u043a\u0430\",\n            12: \"\u0422\u043e\u0432\u0430\u0440\u044b \u043d\u0430\u0440\u043e\u0434\u043d\u043e\u0433\u043e \u043f\u043e\u0442\u0440\u0435\u0431\u043b\u0435\u043d\u0438\u044f\",\n            13: \"\u0422\u043e\u0440\u0433\u043e\u0432\u043b\u044f\",\n            14: \"\u0421\u0442\u0440\u043e\u0438\u0442\u0435\u043b\u044c\u0441\u0442\u0432\u043e\",\n            15: \"\u042d\u043d\u0435\u0440\u0433\u0435\u0442\u0438\u043a\u0430\",\n            16: \"\u041f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0441\u0442\u0432\u043e\",\n            17: \"\u0414\u043e\u0431\u044b\u0447\u0430 \u043f\u043e\u043b\u0435\u0437\u043d\u044b\u0445 \u0438\u0441\u043a\u043e\u043f\u0430\u0435\u043c\u044b\u0445\",\n            18: \"\u0421\u0435\u043b\u044c\u0441\u043a\u043e\u0435 \u0445\u043e\u0437\u044f\u0439\u0441\u0442\u0432\u043e\",\n            19: \"\u0414\u0440\u0443\u0433\u043e\u0435\",\n        }\n        industry_col = [\n            col\n            for col in self.df.columns\n            if col.startswith(f\"Q{industry_Qind}\") and self.df[col].dtype == \"int64\"\n        ][0]\n        industry_counts = self.df[industry_col].value_counts()\n        industry_counts.index = industry_counts.index.to_series().map(industry_codes)\n        industry_counts = industry_counts.to_dict()\n        return industry_counts\n\n    def get_job_distr(self, job_Qinds: int = 13) -&gt; Dict[str, int]:\n        \"\"\"Returns the distribution of selected job functions.\n        This method extracts responses from a specific question in the table.\n\n        Args:\n            job_Qinds (int, optional): Index of the job-related question. Defaults to 13.\n\n        Returns:\n            Dict[str, int]: Jobs labels mapped to selection counts.\n        \"\"\"\n        job_cols = [\n            col\n            for col in self.df.columns\n            if col.startswith(f\"Q{job_Qinds}\") and self.df[col].dtype == \"int64\"\n        ]\n        jobs_counts = self.df[job_cols].sum()\n        jobs_counts = jobs_counts[jobs_counts &gt; 0].sort_values(ascending=False)\n        jobs_counts = jobs_counts.to_dict()\n        return jobs_counts\n\n    # below are methods for extracting data, used in boxplots\n    def get_overall_csi(\n        self, csi_Qinds: List[int] = [2, 3, 5, 7, 8, 9]\n    ) -&gt; Dict[str, pd.Series]:\n        \"\"\"Returns average CSI scores across key program components.\n        This method extracts responses from multiple questions in the table.\n\n        Args:\n            csi_Qinds (List[int], optional): Question indices for CSI blocks. Defaults to [2, 3, 5, 7, 8, 9].\n\n        Returns:\n            Dict[str, pd.Series]: Block labels mapped to per-respondent averages.\n        \"\"\"\n        new_colnames = [\n            \"\u041e\u0431\u0449\u0430\u044f \u043e\u0446\u0435\u043d\u043a\u0430&lt;br&gt;\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b (Q2)\",\n            \"\u041d\u0430\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0434\u043e\u0441\u0442\u0438\u0433\u043d\u0443\u0442\u044b&lt;br&gt;\u0446\u0435\u043b\u0438 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f (Q3)\",\n            \"\u0414\u0438\u0437\u0430\u0439\u043d&lt;br&gt;\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b (Q5)\",\n            \"\u041e\u043f\u044b\u0442 \u043d\u0430&lt;br&gt;\u043c\u0435\u0436\u0434\u0443\u043d\u0430\u0440\u043e\u0434\u043d\u044b\u0445&lt;br&gt;\u043c\u043e\u0434\u0443\u043b\u044f\u0445 (Q7)\",\n            \"\u0420\u0430\u0431\u043e\u0442\u0430 \u043a\u043e\u043c\u0430\u043d\u0434\u044b&lt;br&gt;\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b (Q8)\",\n            \"\u041a\u0430\u0447\u0435\u0441\u0442\u0432\u043e \u0433\u0440\u0443\u043f\u043f\u044b (Q9)\",\n        ]\n\n        discrete_rate_cols = []\n        for i in csi_Qinds:\n            discrete_rate_cols.append(\n                [col for col in self.df.columns if col.startswith(f\"Q{i}\")]\n            )\n\n        csi_data = {}\n        for name, col in zip(new_colnames, discrete_rate_cols):\n            mean_series = self.df[col].mean(axis=1)\n            csi_data[name] = mean_series\n        return csi_data\n\n    def calulate_csi(self, csi_data: Dict[str, List[float]]) -&gt; float:\n        \"\"\"Calculates the overall CSI from component-level CSI data.\n\n        Args:\n            csi_data (Dict[str, List[float]]): Average component scores for each section.\n\n        Returns:\n            float: Averaged overall CSI score.\n        \"\"\"\n        component_csis = []\n        for value in list(csi_data.values()):\n            component_csis.append(sum(value) / len(value))\n        return sum(component_csis) / len(component_csis)\n\n    def _get_csi(self, new_colnames: List[str], csi_Qind: int) -&gt; Dict[str, pd.Series]:\n        \"\"\"Internal helper for extracting CSI block data.\n\n        Args:\n            new_colnames (List[str]): New labels for each CSI subquestion.\n            csi_Qind (int): Index of the CSI block question.\n\n        Returns:\n            Dict[str, pd.Series]: Subquestion labels mapped to rating series.\n        \"\"\"\n        csi_cols = [col for col in self.df.columns if col.startswith(f\"Q{csi_Qind}\")]\n        ratings = [self.df[col] for col in csi_cols]\n        csi_data = dict(zip(new_colnames, ratings))\n        return csi_data\n\n    def get_basic_csi(self, csi_Qind: int = 2) -&gt; Dict[str, pd.Series]:\n        \"\"\"Returns CSI data for the overall csi block.\n        This method extracts responses from a specific question in the table.\n\n        Args:\n            csi_Qind (int, optional): Question index for this block. Defaults to 2.\n\n        Returns:\n            Dict[str, pd.Series]: CSI item labels mapped to rating series.\n        \"\"\"\n        new_colnames = [\n            \"\u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u0438\u0432\u043d\u0430\u044f&lt;br&gt;\u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0430\",\n            \"\u041f\u0440\u0438\u043e\u0431\u0440\u0435\u0442\u0435\u043d\u043d\u044b\u0435&lt;br&gt;\u0437\u043d\u0430\u043d\u0438\u044f\",\n            \"\u041f\u041f\u0421\",\n        ]\n        return self._get_csi(new_colnames, csi_Qind)\n\n    def get_design_csi(self, csi_Qind: int = 5) -&gt; Dict[str, pd.Series]:\n        \"\"\"Returns CSI data for the 'Program Design' block.\n        This method extracts responses from a specific question in the table.\n\n        Args:\n            csi_Qind (int, optional): Question index for this block. Defaults to 5.\n\n        Returns:\n            Dict[str, pd.Series]: CSI item labels mapped to rating series.\n        \"\"\"\n        new_colnames = [\n            \"\u041b\u043e\u0433\u0438\u0447\u043d\u043e\u0441\u0442\u044c&lt;br&gt;\u0441\u043e\u0434\u0435\u0440\u0436\u0430\u043d\u0438\u044f\",\n            \"\u0411\u0430\u043b\u0430\u043d\u0441 \u0442\u0435\u043e\u0440\u0438\u0438&lt;br&gt;\u0438 \u043f\u0440\u0430\u043a\u0442\u0438\u043a\u0438\",\n            \"\u041f\u0440\u0438\u043c\u0435\u043d\u0438\u043c\u043e\u0441\u0442\u044c&lt;br&gt;\u0437\u043d\u0430\u043d\u0438\u0439\",\n            \"\u0410\u043a\u0442\u0443\u0430\u043b\u044c\u043d\u043e\u0441\u0442\u044c&lt;br&gt;\u0437\u043d\u0430\u043d\u0438\u0439\",\n            \"\u0421\u043e\u043e\u0442\u043d\u043e\u0448\u0435\u043d\u0438\u0435&lt;br&gt;\u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u044b\u0445&lt;br&gt;\u0438 \u0440\u0435\u0433\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u044b\u0445&lt;br&gt;\u043c\u043e\u0434\u0443\u043b\u0435\u0439\",\n            \"\u0414\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0441\u0442\u044c&lt;br&gt;\u043f\u0440\u043e\u0435\u043a\u0442\u043d\u043e\u0439&lt;br&gt;\u0440\u0430\u0431\u043e\u0442\u044b\",\n            \"\u041a\u0430\u0447\u0435\u0441\u0442\u0432\u043e&lt;br&gt;\u0432\u044b\u0441\u0442\u0443\u043f\u0430\u044e\u0449\u0438\u0445\",\n        ]\n        return self._get_csi(new_colnames, csi_Qind)\n\n    def get_intern_modules_csi(self, csi_Qind: int = 7) -&gt; Dict[str, pd.Series]:\n        \"\"\"Returns CSI data for the 'International Modules' block.\n\n        Args:\n            csi_Qind (int, optional): Question index for this block. Defaults to 7.\n\n        Returns:\n            Dict[str, pd.Series]: CSI item labels mapped to rating series.\n        \"\"\"\n        new_colnames = [\n            \"\u041a\u0430\u0447\u0435\u0441\u0442\u0432\u043e&lt;br&gt;\u043a\u0435\u0439\u0441\u043e\u0432\",\n            \"\u041f\u0440\u0438\u043c\u0435\u043d\u0438\u043c\u043e\u0441\u0442\u044c&lt;br&gt;\u0437\u043d\u0430\u043d\u0438\u0439\",\n            \"\u0413\u0440\u0443\u043f\u043f\u043e\u0432\u0430\u044f&lt;br&gt;\u0440\u0430\u0431\u043e\u0442\u0430\",\n            \"\u0412\u044b\u0431\u043e\u0440&lt;br&gt;\u043b\u043e\u043a\u0430\u0446\u0438\u0439\",\n        ]\n        return self._get_csi(new_colnames, csi_Qind)\n\n    def get_support_csi(self, csi_Qind: int = 8) -&gt; Dict[str, pd.Series]:\n        \"\"\"Returns CSI data for the 'Program Team Support' block.\n        This method extracts responses from a specific question in the table.\n\n        Args:\n            csi_Qind (int, optional): Question index for this block. Defaults to 8.\n\n        Returns:\n            Dict[str, pd.Series]: CSI item labels mapped to rating series.\n        \"\"\"\n        new_colnames = [\n            \"\u041e\u0442\u043a\u043b\u0438\u043a&lt;br&gt;\u043d\u0430 \u043f\u043e\u0442\u0440\u0435\u0431\u043d\u043e\u0441\u0442\u0438\",\n            \"\u041e\u0440\u0433\u0430\u043d\u0438\u0437\u0430\u0446\u0438\u044f&lt;br&gt;\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0433\u043e&lt;br&gt;\u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430\",\n        ]\n        return self._get_csi(new_colnames, csi_Qind)\n\n    def get_group_csi(self, csi_Qind: int = 9) -&gt; Dict[str, pd.Series]:\n        \"\"\"Returns CSI data for the 'Group Quality' block.\n\n        Args:\n            csi_Qind (int, optional): Question index for this block. Defaults to 9.\n\n        Returns:\n            Dict[str, pd.Series]: CSI item labels mapped to rating series.\n        \"\"\"\n        new_colnames = [\n            \"\u041f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0430\\n\u0438 \u0432\u0437\u0430\u0438\u043c\u043e\u043f\u043e\u043c\u043e\u0449\u044c\",\n            \"\u041e\u043f\u044b\u0442 \u0438 \u0437\u043d\u0430\u043d\u0438\u044f\\n\u043e\u0434\u043d\u043e\u0433\u0440\u0443\u043f\u043f\u043d\u0438\u043a\u043e\u0432\",\n            \"\u0420\u0430\u0437\u043d\u043e\u043e\u0431\u0440\u0430\u0437\u0438\u0435\\n\u0438\u043d\u0434\u0443\u0441\u0442\u0440\u0438\u0439\",\n            \"\u041f\u0440\u0438\u043e\u0431\u0440\u0438\u0442\u0435\u043d\u0438\u0435\\n\u0434\u0435\u043b\u043e\u0432\u044b\u0445\\n\u043a\u043e\u043d\u0442\u0430\u043a\u0442\u043e\u0432\",\n        ]\n        return self._get_csi(new_colnames, csi_Qind)\n\n    # below are methods for extracting data, used in barplots\n    def _get_program_nps(self, nps_Qind: str = \"12.1\") -&gt; float:\n        \"\"\"Computes Net Promoter Score (NPS) from the program recommendation question.\n        This method extracts responses from a specific question in the table.\n\n        Args:\n            nps_Qind (str, optional): Index of the NPS question. Defaults to \"12.1\".\n\n        Returns:\n            float: Calculated NPS value.\n        \"\"\"\n        nps_colname = f\"Q{nps_Qind}  - \ud83d\udd34  \u0413\u043e\u0442\u043e\u0432\u044b \u043b\u0438 \u0432\u044b \u043f\u043e\u0440\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u043e\u0432\u0430\u0442\u044c \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0443 \u0441\u0432\u043e\u0438\u043c \u0434\u0440\u0443\u0437\u044c\u044f\u043c/\u043a\u043e\u043b\u043b\u0435\u0433\u0430\u043c?\"\n        num_students = self.df.shape[0]\n        num_promoters = self.df[self.df[nps_colname] &gt;= 9].shape[0]\n        num_critics = self.df[self.df[nps_colname] &lt;= 6].shape[0]\n        nps_value = int((num_promoters - num_critics) / num_students * 100)\n        return nps_value\n\n    def get_industry_nps(self) -&gt; Tuple[List[str], List[int], List[str]]:\n        \"\"\"Returns industry-level NPS comparison data for barplot rendering.\n        This method extracts responses from a specific question in the table.\n\n        Returns:\n            Tuple[List[str], List[int], List[str]]: Labels, values, and color mapping used in a barplot.\n        \"\"\"\n        nps_value = self._get_program_nps()\n        labels = [\n            \"\u0423\u0440\u043e\u0432\u0435\u043d\u044c '\u041e\u0442\u043b\u0438\u0447\u043d\u043e'\\n by Quesionstar\",\n            \"EMBA-35\",\n            \"\u0421\u0444\u0435\u0440\u0430 \u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u044f\",\n            \"\u0421\u0444\u0435\u0440\u0430 \u0432\u044b\u0441\u0448\u0435\u0433\u043e\\n\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u044f\",\n        ]\n        values = [30, nps_value, 42, 51]\n        colors = [\"#A9A9A9\"] * len(values)\n        colors[1] = \"#FF007F\"\n        return labels, values, colors\n\n    def get_programs_nps(self) -&gt; Tuple[List[str], List[int], List[str]]:\n        \"\"\"Returns NPS data comparing different program cohorts.\n        This method extracts responses from a specific question in the table.\n\n        Returns:\n            Tuple[List[str], List[int], List[str]]: Labels, values, and color mapping used in a barplot.\n        \"\"\"\n        nps_value = self._get_program_nps()\n        labels = [\n            \"EMBA-31+32\",\n            \"EMBA-33\",\n            \"EMBA-34\",\n            \"EMBA-35\",\n            \"SKOLKOVO DEGREE\",\n            \"SKOLKOVO EMBA average\",\n        ]\n        values = [57, 47, 51, nps_value, 65, 77]\n        colors = [\"#A9A9A9\"] * len(values)\n        colors[3] = \"#FF007F\"\n        return labels, values, colors\n\n    def get_pilos(self, nps_Qind: str = 3) -&gt; pd.DataFrame:\n        \"\"\"Returns counts of ratings for each PILO (Program Intended Learning Outcome).\n        This method extracts responses from a specific question in the table.\n\n        Args:\n            nps_Qind (str, optional): Index of the PILO question. Defaults to 3.\n\n        Returns:\n            pd.DataFrame: Aggregated rating counts per PILO item.\n        \"\"\"\n        q3_cols = [col for col in self.df.columns if col.startswith(f\"Q{nps_Qind}\")]\n        new_colnames = [\n            \"\u042d\u043a\u0441\u043f\u0435\u0440\u0442\u043d\u044b\u0439&lt;br&gt;\u0443\u0440\u043e\u0432\u0435\u043d\u044c \u0437\u043d\u0430\u043d\u0438\u044f&lt;br&gt;\u0431\u0438\u0437\u043d\u0435\u0441-\u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\",\n            \"\u0410\u043d\u0430\u043b\u0438\u0437 \u0434\u0430\u043d\u043d\u044b\u0445&lt;br&gt;\u0434\u043b\u044f \u043f\u0440\u0438\u043d\u044f\u0442\u0438\u044f&lt;br&gt;\u0440\u0435\u0448\u0435\u043d\u0438\u0439\",\n            \"\u041e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435&lt;br&gt;\u0441\u0442\u0440\u0430\u0442\u0435\u0433\u0438\u0438 \u0434\u043b\u044f&lt;br&gt;\u0443\u0441\u0442\u043e\u0439\u0447\u0438\u0432\u043e\u0433\u043e&lt;br&gt;\u0440\u0430\u0437\u0432\u0438\u0442\u0438\u044f\",\n            \"\u0418\u043d\u0442\u0435\u0433\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u043e\u0435&lt;br&gt;\u043b\u0438\u0434\u0435\u0440\u0441\u0442\u0432\u043e\",\n            \"\u042d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u0430\u044f&lt;br&gt;\u043a\u043e\u043c\u043c\u0443\u043d\u0438\u043a\u0430\u0446\u0438\u044f\",\n            \"\u0421\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435&lt;br&gt;\u0441\u0442\u0440\u0430\u0442\u0435\u0433\u0438\u0439\",\n            \"\u041e\u0446\u0435\u043d\u043a\u0430 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0430&lt;br&gt;\u0438 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0439\",\n            \"\u0412\u043d\u0435\u0434\u0440\u0435\u043d\u0438\u0435&lt;br&gt;ERS\",\n            \"\u041a\u0440\u0435\u0430\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u044c&lt;br&gt;\u043d\u043e\u0432\u0430\u0442\u043e\u0440\u0441\u0442\u0432\u043e\",\n            \"\u041f\u0440\u0435\u0434\u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0435&lt;br&gt;\u043c\u044b\u0448\u043b\u0435\u043d\u0438\u0435\",\n        ]\n        PILOs_df = self.df[q3_cols]\n        PILOs_df.columns = new_colnames\n        PILOs_df = PILOs_df.astype(int)\n        PILOs_df = PILOs_df.melt(var_name=\"param\", value_name=\"score\")\n        score_counts = (\n            PILOs_df.groupby([\"param\", \"score\"])\n            .size()\n            .unstack(fill_value=0)\n            .reindex(columns=range(1, 11), fill_value=0)\n        ).reset_index()\n        return score_counts\n\n    def get_top_lectors(self, lectors_Qind: int = 6) -&gt; Dict[str, int]:\n        \"\"\"Returns a ranked count of most frequently selected lecturers.\n        This method extracts responses from a specific question in the table.\n\n        Args:\n            lectors_Qind (int, optional): Index of the lecturer evaluation question. Defaults to 6.\n\n        Returns:\n            Dict[str, int]: Lecturer names mapped to selection counts.\n        \"\"\"\n        lectors_cols = [\n            col for col in self.df.columns if col.startswith(f\"Q{lectors_Qind}\")\n        ]\n        all_lectors = self.df[lectors_cols]\n        mask_all_zeros = (all_lectors == 0).all(axis=1)\n        zeros_count = mask_all_zeros.sum()\n        lectors = all_lectors.loc[~mask_all_zeros, lectors_cols].values.flatten()\n        lectors = [lector for lector in lectors if lector != 0]\n        lectors_counts = pd.Series(lectors).value_counts()\n        lectors_counts[\"\u041d\u0438\u043a\u0442\u043e\"] = zeros_count\n        lectors_counts = lectors_counts.sort_values(ascending=True).to_dict()\n        return lectors_counts\n\n    def get_collaborators(self, collab_Qind: int = 11) -&gt; Dict[str, int]:\n        \"\"\"Returns the distribution of preferred alumni collaboration formats.\n\n        Args:\n            collab_Qind (int, optional): Index of the collaboration question. Defaults to 11.\n\n        Returns:\n            Dict[str, int]: Collaboration types mapped to respondent counts.\n        \"\"\"\n        new_colnames = [\n            \"\u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u043f\u0440\u0438\u0433\u043b\u0430\u0448\u0435\u043d\u043d\u043e\u0433\u043e \u0441\u043f\u0438\u043a\u0435\u0440\u0430\",\n            \"\u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u043c\u0435\u043d\u0442\u043e\u0440\u0430\",\n            \"\u043c\u0435\u0440\u043e\u043f\u0440\u0438\u044f\u0442\u0438\u044f\u0445 \u0434\u043b\u044f \u0432\u044b\u043f\u0443\u0441\u043a\u043d\u0438\u043a\u043e\u0432\",\n            \"\u0430\u0434\u043c\u0438\u0441\u0441\u0438\u0438\",\n            \"\u0434\u0440\u0443\u0433\u043e\u0435\",\n            \"\u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u043f\u0440\u043e\u0442\u0430\u0433\u043e\u043d\u0438\u0441\u0442\u0430\",\n            \"\u043e\u0442\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0441\u044c\",\n        ]\n        events_cols = [\n            col\n            for col in self.df.columns\n            if col.startswith(f\"Q{collab_Qind}\")\n            and not col.startswith(f\"Q{collab_Qind}.1.\")\n        ]\n        all_events = self.df[events_cols].replace(\"No comments\", False).astype(bool)\n        all_events[\"\u041e\u0442\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0441\u044c\"] = (~all_events).all(axis=1)\n        all_events.columns = new_colnames\n\n        events_counts = {}\n        for col in new_colnames:\n            events_counts[col] = all_events[col].sum()\n        events_counts = pd.Series(events_counts).sort_values(ascending=True).to_dict()\n        return events_counts\n</code></pre>"},{"location":"references/backend/#app.backend.data_extractors.ExitEmbaExtractor.__init__","title":"<code>__init__(table_path)</code>","text":"<p>Initialize an extractor object</p> <p>Parameters:</p> Name Type Description Default <code>table_path</code> <code>str | IO</code> <p>string with a path to a structured Excel tables or a file-like object.</p> required Source code in <code>src/app/backend/data_extractors.py</code> <pre><code>def __init__(self, table_path: str | IO):\n    \"\"\"Initialize an extractor object\n\n    Args:\n        table_path (str | IO): string with a path to a structured Excel tables or a file-like object.\n    \"\"\"\n    self.df = pd.read_excel(table_path)\n</code></pre>"},{"location":"references/backend/#app.backend.data_extractors.ExitEmbaExtractor.calulate_csi","title":"<code>calulate_csi(csi_data)</code>","text":"<p>Calculates the overall CSI from component-level CSI data.</p> <p>Parameters:</p> Name Type Description Default <code>csi_data</code> <code>Dict[str, List[float]]</code> <p>Average component scores for each section.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Averaged overall CSI score.</p> Source code in <code>src/app/backend/data_extractors.py</code> <pre><code>def calulate_csi(self, csi_data: Dict[str, List[float]]) -&gt; float:\n    \"\"\"Calculates the overall CSI from component-level CSI data.\n\n    Args:\n        csi_data (Dict[str, List[float]]): Average component scores for each section.\n\n    Returns:\n        float: Averaged overall CSI score.\n    \"\"\"\n    component_csis = []\n    for value in list(csi_data.values()):\n        component_csis.append(sum(value) / len(value))\n    return sum(component_csis) / len(component_csis)\n</code></pre>"},{"location":"references/backend/#app.backend.data_extractors.ExitEmbaExtractor.get_age_distr","title":"<code>get_age_distr(age_Qind=15)</code>","text":"<p>Returns the distribution of respondents by age group. This method extracts responses from a specific question in the table.</p> <p>Parameters:</p> Name Type Description Default <code>age_Qind</code> <code>int</code> <p>The index of the question containing age group information. Defaults to 15.</p> <code>15</code> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Dict[str, int]: A dictionary mapping age group labels (e.g., \"25-34\")</p> <code>Dict[str, int]</code> <p>to the number of respondents in each group.</p> Source code in <code>src/app/backend/data_extractors.py</code> <pre><code>def get_age_distr(self, age_Qind: int = 15) -&gt; Dict[str, int]:\n    \"\"\"Returns the distribution of respondents by age group.\n    This method extracts responses from a specific question in the table.\n\n    Args:\n        age_Qind (int, optional): The index of the question containing age group information. Defaults to 15.\n\n    Returns:\n        Dict[str, int]: A dictionary mapping age group labels (e.g., \"25-34\")\n        to the number of respondents in each group.\n    \"\"\"\n    age_groups = {\n        1.0: \"18-24\",\n        2.0: \"25-34\",\n        3.0: \"35-44\",\n        4.0: \"45-54\",\n        5.0: \"55+\",\n    }\n    age_counts = self.df[f\"Q{age_Qind} \ud83d\udd34  \u0423\u043a\u0430\u0436\u0438\u0442\u0435 \u0432\u0430\u0448  \u0432\u043e\u0437\u0440\u0430\u0441\u0442\"].value_counts()\n    age_counts.index = age_counts.index.to_series().map(age_groups)\n    age_counts = age_counts.to_dict()\n    return age_counts\n</code></pre>"},{"location":"references/backend/#app.backend.data_extractors.ExitEmbaExtractor.get_basic_csi","title":"<code>get_basic_csi(csi_Qind=2)</code>","text":"<p>Returns CSI data for the overall csi block. This method extracts responses from a specific question in the table.</p> <p>Parameters:</p> Name Type Description Default <code>csi_Qind</code> <code>int</code> <p>Question index for this block. Defaults to 2.</p> <code>2</code> <p>Returns:</p> Type Description <code>Dict[str, Series]</code> <p>Dict[str, pd.Series]: CSI item labels mapped to rating series.</p> Source code in <code>src/app/backend/data_extractors.py</code> <pre><code>def get_basic_csi(self, csi_Qind: int = 2) -&gt; Dict[str, pd.Series]:\n    \"\"\"Returns CSI data for the overall csi block.\n    This method extracts responses from a specific question in the table.\n\n    Args:\n        csi_Qind (int, optional): Question index for this block. Defaults to 2.\n\n    Returns:\n        Dict[str, pd.Series]: CSI item labels mapped to rating series.\n    \"\"\"\n    new_colnames = [\n        \"\u0410\u0434\u043c\u0438\u043d\u0438\u0441\u0442\u0440\u0430\u0442\u0438\u0432\u043d\u0430\u044f&lt;br&gt;\u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0430\",\n        \"\u041f\u0440\u0438\u043e\u0431\u0440\u0435\u0442\u0435\u043d\u043d\u044b\u0435&lt;br&gt;\u0437\u043d\u0430\u043d\u0438\u044f\",\n        \"\u041f\u041f\u0421\",\n    ]\n    return self._get_csi(new_colnames, csi_Qind)\n</code></pre>"},{"location":"references/backend/#app.backend.data_extractors.ExitEmbaExtractor.get_collaborators","title":"<code>get_collaborators(collab_Qind=11)</code>","text":"<p>Returns the distribution of preferred alumni collaboration formats.</p> <p>Parameters:</p> Name Type Description Default <code>collab_Qind</code> <code>int</code> <p>Index of the collaboration question. Defaults to 11.</p> <code>11</code> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Dict[str, int]: Collaboration types mapped to respondent counts.</p> Source code in <code>src/app/backend/data_extractors.py</code> <pre><code>def get_collaborators(self, collab_Qind: int = 11) -&gt; Dict[str, int]:\n    \"\"\"Returns the distribution of preferred alumni collaboration formats.\n\n    Args:\n        collab_Qind (int, optional): Index of the collaboration question. Defaults to 11.\n\n    Returns:\n        Dict[str, int]: Collaboration types mapped to respondent counts.\n    \"\"\"\n    new_colnames = [\n        \"\u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u043f\u0440\u0438\u0433\u043b\u0430\u0448\u0435\u043d\u043d\u043e\u0433\u043e \u0441\u043f\u0438\u043a\u0435\u0440\u0430\",\n        \"\u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u043c\u0435\u043d\u0442\u043e\u0440\u0430\",\n        \"\u043c\u0435\u0440\u043e\u043f\u0440\u0438\u044f\u0442\u0438\u044f\u0445 \u0434\u043b\u044f \u0432\u044b\u043f\u0443\u0441\u043a\u043d\u0438\u043a\u043e\u0432\",\n        \"\u0430\u0434\u043c\u0438\u0441\u0441\u0438\u0438\",\n        \"\u0434\u0440\u0443\u0433\u043e\u0435\",\n        \"\u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u043f\u0440\u043e\u0442\u0430\u0433\u043e\u043d\u0438\u0441\u0442\u0430\",\n        \"\u043e\u0442\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0441\u044c\",\n    ]\n    events_cols = [\n        col\n        for col in self.df.columns\n        if col.startswith(f\"Q{collab_Qind}\")\n        and not col.startswith(f\"Q{collab_Qind}.1.\")\n    ]\n    all_events = self.df[events_cols].replace(\"No comments\", False).astype(bool)\n    all_events[\"\u041e\u0442\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0441\u044c\"] = (~all_events).all(axis=1)\n    all_events.columns = new_colnames\n\n    events_counts = {}\n    for col in new_colnames:\n        events_counts[col] = all_events[col].sum()\n    events_counts = pd.Series(events_counts).sort_values(ascending=True).to_dict()\n    return events_counts\n</code></pre>"},{"location":"references/backend/#app.backend.data_extractors.ExitEmbaExtractor.get_design_csi","title":"<code>get_design_csi(csi_Qind=5)</code>","text":"<p>Returns CSI data for the 'Program Design' block. This method extracts responses from a specific question in the table.</p> <p>Parameters:</p> Name Type Description Default <code>csi_Qind</code> <code>int</code> <p>Question index for this block. Defaults to 5.</p> <code>5</code> <p>Returns:</p> Type Description <code>Dict[str, Series]</code> <p>Dict[str, pd.Series]: CSI item labels mapped to rating series.</p> Source code in <code>src/app/backend/data_extractors.py</code> <pre><code>def get_design_csi(self, csi_Qind: int = 5) -&gt; Dict[str, pd.Series]:\n    \"\"\"Returns CSI data for the 'Program Design' block.\n    This method extracts responses from a specific question in the table.\n\n    Args:\n        csi_Qind (int, optional): Question index for this block. Defaults to 5.\n\n    Returns:\n        Dict[str, pd.Series]: CSI item labels mapped to rating series.\n    \"\"\"\n    new_colnames = [\n        \"\u041b\u043e\u0433\u0438\u0447\u043d\u043e\u0441\u0442\u044c&lt;br&gt;\u0441\u043e\u0434\u0435\u0440\u0436\u0430\u043d\u0438\u044f\",\n        \"\u0411\u0430\u043b\u0430\u043d\u0441 \u0442\u0435\u043e\u0440\u0438\u0438&lt;br&gt;\u0438 \u043f\u0440\u0430\u043a\u0442\u0438\u043a\u0438\",\n        \"\u041f\u0440\u0438\u043c\u0435\u043d\u0438\u043c\u043e\u0441\u0442\u044c&lt;br&gt;\u0437\u043d\u0430\u043d\u0438\u0439\",\n        \"\u0410\u043a\u0442\u0443\u0430\u043b\u044c\u043d\u043e\u0441\u0442\u044c&lt;br&gt;\u0437\u043d\u0430\u043d\u0438\u0439\",\n        \"\u0421\u043e\u043e\u0442\u043d\u043e\u0448\u0435\u043d\u0438\u0435&lt;br&gt;\u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u044b\u0445&lt;br&gt;\u0438 \u0440\u0435\u0433\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u044b\u0445&lt;br&gt;\u043c\u043e\u0434\u0443\u043b\u0435\u0439\",\n        \"\u0414\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\u0441\u0442\u044c&lt;br&gt;\u043f\u0440\u043e\u0435\u043a\u0442\u043d\u043e\u0439&lt;br&gt;\u0440\u0430\u0431\u043e\u0442\u044b\",\n        \"\u041a\u0430\u0447\u0435\u0441\u0442\u0432\u043e&lt;br&gt;\u0432\u044b\u0441\u0442\u0443\u043f\u0430\u044e\u0449\u0438\u0445\",\n    ]\n    return self._get_csi(new_colnames, csi_Qind)\n</code></pre>"},{"location":"references/backend/#app.backend.data_extractors.ExitEmbaExtractor.get_group_csi","title":"<code>get_group_csi(csi_Qind=9)</code>","text":"<p>Returns CSI data for the 'Group Quality' block.</p> <p>Parameters:</p> Name Type Description Default <code>csi_Qind</code> <code>int</code> <p>Question index for this block. Defaults to 9.</p> <code>9</code> <p>Returns:</p> Type Description <code>Dict[str, Series]</code> <p>Dict[str, pd.Series]: CSI item labels mapped to rating series.</p> Source code in <code>src/app/backend/data_extractors.py</code> <pre><code>def get_group_csi(self, csi_Qind: int = 9) -&gt; Dict[str, pd.Series]:\n    \"\"\"Returns CSI data for the 'Group Quality' block.\n\n    Args:\n        csi_Qind (int, optional): Question index for this block. Defaults to 9.\n\n    Returns:\n        Dict[str, pd.Series]: CSI item labels mapped to rating series.\n    \"\"\"\n    new_colnames = [\n        \"\u041f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0430\\n\u0438 \u0432\u0437\u0430\u0438\u043c\u043e\u043f\u043e\u043c\u043e\u0449\u044c\",\n        \"\u041e\u043f\u044b\u0442 \u0438 \u0437\u043d\u0430\u043d\u0438\u044f\\n\u043e\u0434\u043d\u043e\u0433\u0440\u0443\u043f\u043f\u043d\u0438\u043a\u043e\u0432\",\n        \"\u0420\u0430\u0437\u043d\u043e\u043e\u0431\u0440\u0430\u0437\u0438\u0435\\n\u0438\u043d\u0434\u0443\u0441\u0442\u0440\u0438\u0439\",\n        \"\u041f\u0440\u0438\u043e\u0431\u0440\u0438\u0442\u0435\u043d\u0438\u0435\\n\u0434\u0435\u043b\u043e\u0432\u044b\u0445\\n\u043a\u043e\u043d\u0442\u0430\u043a\u0442\u043e\u0432\",\n    ]\n    return self._get_csi(new_colnames, csi_Qind)\n</code></pre>"},{"location":"references/backend/#app.backend.data_extractors.ExitEmbaExtractor.get_industry_distr","title":"<code>get_industry_distr(industry_Qind=14)</code>","text":"<p>Returns the distribution of respondents by industry. This method extracts responses from a specific question in the table.</p> <p>Parameters:</p> Name Type Description Default <code>industry_Qind</code> <code>int</code> <p>Index of the industry question. Defaults to 14.</p> <code>14</code> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Dict[str, int]: Industry labels mapped to respondent counts.</p> Source code in <code>src/app/backend/data_extractors.py</code> <pre><code>def get_industry_distr(self, industry_Qind: int = 14) -&gt; Dict[str, int]:\n    \"\"\"Returns the distribution of respondents by industry.\n    This method extracts responses from a specific question in the table.\n\n    Args:\n        industry_Qind (int, optional): Index of the industry question. Defaults to 14.\n\n    Returns:\n        Dict[str, int]: Industry labels mapped to respondent counts.\n    \"\"\"\n    industry_codes = {\n        1: \"\u0421\u0440\u0435\u0434\u0441\u0442\u0432\u0430 \u043c\u0430\u0441\u0441\u043e\u0432\u043e\u0439 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u0438 \u0440\u0430\u0437\u0432\u043b\u0435\u0447\u0435\u043d\u0438\u044f\",\n        2: \"\u0417\u0434\u0440\u0430\u0432\u043e\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435\",\n        3: \"\u041e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u0435\",\n        4: \"\u041d\u0435\u043a\u043e\u043c\u043c\u0435\u0440\u0447\u0435\u0441\u043a\u0438\u0435 \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u0430\u0446\u0438\u0438, \u043d\u0435\u043f\u0440\u0430\u0432\u0438\u0442\u0435\u043b\u044c\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0435 \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u0430\u0446\u0438\u0438\",\n        5: \"\u0413\u043e\u0441\u0443\u0434\u0430\u0440\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0439 \u0441\u0435\u043a\u0442\u043e\u0440\",\n        6: \"\u041a\u043e\u043d\u0441\u0430\u043b\u0442\u0438\u043d\u0433\",\n        7: \"\u041d\u0435\u0434\u0432\u0438\u0436\u0438\u043c\u043e\u0441\u0442\u044c\",\n        8: \"\u0424\u0438\u043d\u0430\u043d\u0441\u044b\",\n        9: \"\u0422\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0438\",\n        10: \"\u041e\u0442\u0435\u043b\u0438, \u0420\u0435\u0441\u0442\u043e\u0440\u0430\u043d\u044b, \u041a\u0435\u0439\u0442\u0435\u0440\u0438\u043d\u0433\",\n        11: \"\u041b\u043e\u0433\u0438\u0441\u0442\u0438\u043a\u0430\",\n        12: \"\u0422\u043e\u0432\u0430\u0440\u044b \u043d\u0430\u0440\u043e\u0434\u043d\u043e\u0433\u043e \u043f\u043e\u0442\u0440\u0435\u0431\u043b\u0435\u043d\u0438\u044f\",\n        13: \"\u0422\u043e\u0440\u0433\u043e\u0432\u043b\u044f\",\n        14: \"\u0421\u0442\u0440\u043e\u0438\u0442\u0435\u043b\u044c\u0441\u0442\u0432\u043e\",\n        15: \"\u042d\u043d\u0435\u0440\u0433\u0435\u0442\u0438\u043a\u0430\",\n        16: \"\u041f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0441\u0442\u0432\u043e\",\n        17: \"\u0414\u043e\u0431\u044b\u0447\u0430 \u043f\u043e\u043b\u0435\u0437\u043d\u044b\u0445 \u0438\u0441\u043a\u043e\u043f\u0430\u0435\u043c\u044b\u0445\",\n        18: \"\u0421\u0435\u043b\u044c\u0441\u043a\u043e\u0435 \u0445\u043e\u0437\u044f\u0439\u0441\u0442\u0432\u043e\",\n        19: \"\u0414\u0440\u0443\u0433\u043e\u0435\",\n    }\n    industry_col = [\n        col\n        for col in self.df.columns\n        if col.startswith(f\"Q{industry_Qind}\") and self.df[col].dtype == \"int64\"\n    ][0]\n    industry_counts = self.df[industry_col].value_counts()\n    industry_counts.index = industry_counts.index.to_series().map(industry_codes)\n    industry_counts = industry_counts.to_dict()\n    return industry_counts\n</code></pre>"},{"location":"references/backend/#app.backend.data_extractors.ExitEmbaExtractor.get_industry_nps","title":"<code>get_industry_nps()</code>","text":"<p>Returns industry-level NPS comparison data for barplot rendering. This method extracts responses from a specific question in the table.</p> <p>Returns:</p> Type Description <code>Tuple[List[str], List[int], List[str]]</code> <p>Tuple[List[str], List[int], List[str]]: Labels, values, and color mapping used in a barplot.</p> Source code in <code>src/app/backend/data_extractors.py</code> <pre><code>def get_industry_nps(self) -&gt; Tuple[List[str], List[int], List[str]]:\n    \"\"\"Returns industry-level NPS comparison data for barplot rendering.\n    This method extracts responses from a specific question in the table.\n\n    Returns:\n        Tuple[List[str], List[int], List[str]]: Labels, values, and color mapping used in a barplot.\n    \"\"\"\n    nps_value = self._get_program_nps()\n    labels = [\n        \"\u0423\u0440\u043e\u0432\u0435\u043d\u044c '\u041e\u0442\u043b\u0438\u0447\u043d\u043e'\\n by Quesionstar\",\n        \"EMBA-35\",\n        \"\u0421\u0444\u0435\u0440\u0430 \u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u044f\",\n        \"\u0421\u0444\u0435\u0440\u0430 \u0432\u044b\u0441\u0448\u0435\u0433\u043e\\n\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u044f\",\n    ]\n    values = [30, nps_value, 42, 51]\n    colors = [\"#A9A9A9\"] * len(values)\n    colors[1] = \"#FF007F\"\n    return labels, values, colors\n</code></pre>"},{"location":"references/backend/#app.backend.data_extractors.ExitEmbaExtractor.get_intern_modules_csi","title":"<code>get_intern_modules_csi(csi_Qind=7)</code>","text":"<p>Returns CSI data for the 'International Modules' block.</p> <p>Parameters:</p> Name Type Description Default <code>csi_Qind</code> <code>int</code> <p>Question index for this block. Defaults to 7.</p> <code>7</code> <p>Returns:</p> Type Description <code>Dict[str, Series]</code> <p>Dict[str, pd.Series]: CSI item labels mapped to rating series.</p> Source code in <code>src/app/backend/data_extractors.py</code> <pre><code>def get_intern_modules_csi(self, csi_Qind: int = 7) -&gt; Dict[str, pd.Series]:\n    \"\"\"Returns CSI data for the 'International Modules' block.\n\n    Args:\n        csi_Qind (int, optional): Question index for this block. Defaults to 7.\n\n    Returns:\n        Dict[str, pd.Series]: CSI item labels mapped to rating series.\n    \"\"\"\n    new_colnames = [\n        \"\u041a\u0430\u0447\u0435\u0441\u0442\u0432\u043e&lt;br&gt;\u043a\u0435\u0439\u0441\u043e\u0432\",\n        \"\u041f\u0440\u0438\u043c\u0435\u043d\u0438\u043c\u043e\u0441\u0442\u044c&lt;br&gt;\u0437\u043d\u0430\u043d\u0438\u0439\",\n        \"\u0413\u0440\u0443\u043f\u043f\u043e\u0432\u0430\u044f&lt;br&gt;\u0440\u0430\u0431\u043e\u0442\u0430\",\n        \"\u0412\u044b\u0431\u043e\u0440&lt;br&gt;\u043b\u043e\u043a\u0430\u0446\u0438\u0439\",\n    ]\n    return self._get_csi(new_colnames, csi_Qind)\n</code></pre>"},{"location":"references/backend/#app.backend.data_extractors.ExitEmbaExtractor.get_job_distr","title":"<code>get_job_distr(job_Qinds=13)</code>","text":"<p>Returns the distribution of selected job functions. This method extracts responses from a specific question in the table.</p> <p>Parameters:</p> Name Type Description Default <code>job_Qinds</code> <code>int</code> <p>Index of the job-related question. Defaults to 13.</p> <code>13</code> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Dict[str, int]: Jobs labels mapped to selection counts.</p> Source code in <code>src/app/backend/data_extractors.py</code> <pre><code>def get_job_distr(self, job_Qinds: int = 13) -&gt; Dict[str, int]:\n    \"\"\"Returns the distribution of selected job functions.\n    This method extracts responses from a specific question in the table.\n\n    Args:\n        job_Qinds (int, optional): Index of the job-related question. Defaults to 13.\n\n    Returns:\n        Dict[str, int]: Jobs labels mapped to selection counts.\n    \"\"\"\n    job_cols = [\n        col\n        for col in self.df.columns\n        if col.startswith(f\"Q{job_Qinds}\") and self.df[col].dtype == \"int64\"\n    ]\n    jobs_counts = self.df[job_cols].sum()\n    jobs_counts = jobs_counts[jobs_counts &gt; 0].sort_values(ascending=False)\n    jobs_counts = jobs_counts.to_dict()\n    return jobs_counts\n</code></pre>"},{"location":"references/backend/#app.backend.data_extractors.ExitEmbaExtractor.get_overall_csi","title":"<code>get_overall_csi(csi_Qinds=[2, 3, 5, 7, 8, 9])</code>","text":"<p>Returns average CSI scores across key program components. This method extracts responses from multiple questions in the table.</p> <p>Parameters:</p> Name Type Description Default <code>csi_Qinds</code> <code>List[int]</code> <p>Question indices for CSI blocks. Defaults to [2, 3, 5, 7, 8, 9].</p> <code>[2, 3, 5, 7, 8, 9]</code> <p>Returns:</p> Type Description <code>Dict[str, Series]</code> <p>Dict[str, pd.Series]: Block labels mapped to per-respondent averages.</p> Source code in <code>src/app/backend/data_extractors.py</code> <pre><code>def get_overall_csi(\n    self, csi_Qinds: List[int] = [2, 3, 5, 7, 8, 9]\n) -&gt; Dict[str, pd.Series]:\n    \"\"\"Returns average CSI scores across key program components.\n    This method extracts responses from multiple questions in the table.\n\n    Args:\n        csi_Qinds (List[int], optional): Question indices for CSI blocks. Defaults to [2, 3, 5, 7, 8, 9].\n\n    Returns:\n        Dict[str, pd.Series]: Block labels mapped to per-respondent averages.\n    \"\"\"\n    new_colnames = [\n        \"\u041e\u0431\u0449\u0430\u044f \u043e\u0446\u0435\u043d\u043a\u0430&lt;br&gt;\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b (Q2)\",\n        \"\u041d\u0430\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0434\u043e\u0441\u0442\u0438\u0433\u043d\u0443\u0442\u044b&lt;br&gt;\u0446\u0435\u043b\u0438 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f (Q3)\",\n        \"\u0414\u0438\u0437\u0430\u0439\u043d&lt;br&gt;\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b (Q5)\",\n        \"\u041e\u043f\u044b\u0442 \u043d\u0430&lt;br&gt;\u043c\u0435\u0436\u0434\u0443\u043d\u0430\u0440\u043e\u0434\u043d\u044b\u0445&lt;br&gt;\u043c\u043e\u0434\u0443\u043b\u044f\u0445 (Q7)\",\n        \"\u0420\u0430\u0431\u043e\u0442\u0430 \u043a\u043e\u043c\u0430\u043d\u0434\u044b&lt;br&gt;\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b (Q8)\",\n        \"\u041a\u0430\u0447\u0435\u0441\u0442\u0432\u043e \u0433\u0440\u0443\u043f\u043f\u044b (Q9)\",\n    ]\n\n    discrete_rate_cols = []\n    for i in csi_Qinds:\n        discrete_rate_cols.append(\n            [col for col in self.df.columns if col.startswith(f\"Q{i}\")]\n        )\n\n    csi_data = {}\n    for name, col in zip(new_colnames, discrete_rate_cols):\n        mean_series = self.df[col].mean(axis=1)\n        csi_data[name] = mean_series\n    return csi_data\n</code></pre>"},{"location":"references/backend/#app.backend.data_extractors.ExitEmbaExtractor.get_pilos","title":"<code>get_pilos(nps_Qind=3)</code>","text":"<p>Returns counts of ratings for each PILO (Program Intended Learning Outcome). This method extracts responses from a specific question in the table.</p> <p>Parameters:</p> Name Type Description Default <code>nps_Qind</code> <code>str</code> <p>Index of the PILO question. Defaults to 3.</p> <code>3</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Aggregated rating counts per PILO item.</p> Source code in <code>src/app/backend/data_extractors.py</code> <pre><code>def get_pilos(self, nps_Qind: str = 3) -&gt; pd.DataFrame:\n    \"\"\"Returns counts of ratings for each PILO (Program Intended Learning Outcome).\n    This method extracts responses from a specific question in the table.\n\n    Args:\n        nps_Qind (str, optional): Index of the PILO question. Defaults to 3.\n\n    Returns:\n        pd.DataFrame: Aggregated rating counts per PILO item.\n    \"\"\"\n    q3_cols = [col for col in self.df.columns if col.startswith(f\"Q{nps_Qind}\")]\n    new_colnames = [\n        \"\u042d\u043a\u0441\u043f\u0435\u0440\u0442\u043d\u044b\u0439&lt;br&gt;\u0443\u0440\u043e\u0432\u0435\u043d\u044c \u0437\u043d\u0430\u043d\u0438\u044f&lt;br&gt;\u0431\u0438\u0437\u043d\u0435\u0441-\u0434\u0438\u0441\u0446\u0438\u043f\u043b\u0438\u043d\",\n        \"\u0410\u043d\u0430\u043b\u0438\u0437 \u0434\u0430\u043d\u043d\u044b\u0445&lt;br&gt;\u0434\u043b\u044f \u043f\u0440\u0438\u043d\u044f\u0442\u0438\u044f&lt;br&gt;\u0440\u0435\u0448\u0435\u043d\u0438\u0439\",\n        \"\u041e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435&lt;br&gt;\u0441\u0442\u0440\u0430\u0442\u0435\u0433\u0438\u0438 \u0434\u043b\u044f&lt;br&gt;\u0443\u0441\u0442\u043e\u0439\u0447\u0438\u0432\u043e\u0433\u043e&lt;br&gt;\u0440\u0430\u0437\u0432\u0438\u0442\u0438\u044f\",\n        \"\u0418\u043d\u0442\u0435\u0433\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u043e\u0435&lt;br&gt;\u043b\u0438\u0434\u0435\u0440\u0441\u0442\u0432\u043e\",\n        \"\u042d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u0430\u044f&lt;br&gt;\u043a\u043e\u043c\u043c\u0443\u043d\u0438\u043a\u0430\u0446\u0438\u044f\",\n        \"\u0421\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435&lt;br&gt;\u0441\u0442\u0440\u0430\u0442\u0435\u0433\u0438\u0439\",\n        \"\u041e\u0446\u0435\u043d\u043a\u0430 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0430&lt;br&gt;\u0438 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0438\u0439\",\n        \"\u0412\u043d\u0435\u0434\u0440\u0435\u043d\u0438\u0435&lt;br&gt;ERS\",\n        \"\u041a\u0440\u0435\u0430\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u044c&lt;br&gt;\u043d\u043e\u0432\u0430\u0442\u043e\u0440\u0441\u0442\u0432\u043e\",\n        \"\u041f\u0440\u0435\u0434\u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0435&lt;br&gt;\u043c\u044b\u0448\u043b\u0435\u043d\u0438\u0435\",\n    ]\n    PILOs_df = self.df[q3_cols]\n    PILOs_df.columns = new_colnames\n    PILOs_df = PILOs_df.astype(int)\n    PILOs_df = PILOs_df.melt(var_name=\"param\", value_name=\"score\")\n    score_counts = (\n        PILOs_df.groupby([\"param\", \"score\"])\n        .size()\n        .unstack(fill_value=0)\n        .reindex(columns=range(1, 11), fill_value=0)\n    ).reset_index()\n    return score_counts\n</code></pre>"},{"location":"references/backend/#app.backend.data_extractors.ExitEmbaExtractor.get_programs_nps","title":"<code>get_programs_nps()</code>","text":"<p>Returns NPS data comparing different program cohorts. This method extracts responses from a specific question in the table.</p> <p>Returns:</p> Type Description <code>Tuple[List[str], List[int], List[str]]</code> <p>Tuple[List[str], List[int], List[str]]: Labels, values, and color mapping used in a barplot.</p> Source code in <code>src/app/backend/data_extractors.py</code> <pre><code>def get_programs_nps(self) -&gt; Tuple[List[str], List[int], List[str]]:\n    \"\"\"Returns NPS data comparing different program cohorts.\n    This method extracts responses from a specific question in the table.\n\n    Returns:\n        Tuple[List[str], List[int], List[str]]: Labels, values, and color mapping used in a barplot.\n    \"\"\"\n    nps_value = self._get_program_nps()\n    labels = [\n        \"EMBA-31+32\",\n        \"EMBA-33\",\n        \"EMBA-34\",\n        \"EMBA-35\",\n        \"SKOLKOVO DEGREE\",\n        \"SKOLKOVO EMBA average\",\n    ]\n    values = [57, 47, 51, nps_value, 65, 77]\n    colors = [\"#A9A9A9\"] * len(values)\n    colors[3] = \"#FF007F\"\n    return labels, values, colors\n</code></pre>"},{"location":"references/backend/#app.backend.data_extractors.ExitEmbaExtractor.get_support_csi","title":"<code>get_support_csi(csi_Qind=8)</code>","text":"<p>Returns CSI data for the 'Program Team Support' block. This method extracts responses from a specific question in the table.</p> <p>Parameters:</p> Name Type Description Default <code>csi_Qind</code> <code>int</code> <p>Question index for this block. Defaults to 8.</p> <code>8</code> <p>Returns:</p> Type Description <code>Dict[str, Series]</code> <p>Dict[str, pd.Series]: CSI item labels mapped to rating series.</p> Source code in <code>src/app/backend/data_extractors.py</code> <pre><code>def get_support_csi(self, csi_Qind: int = 8) -&gt; Dict[str, pd.Series]:\n    \"\"\"Returns CSI data for the 'Program Team Support' block.\n    This method extracts responses from a specific question in the table.\n\n    Args:\n        csi_Qind (int, optional): Question index for this block. Defaults to 8.\n\n    Returns:\n        Dict[str, pd.Series]: CSI item labels mapped to rating series.\n    \"\"\"\n    new_colnames = [\n        \"\u041e\u0442\u043a\u043b\u0438\u043a&lt;br&gt;\u043d\u0430 \u043f\u043e\u0442\u0440\u0435\u0431\u043d\u043e\u0441\u0442\u0438\",\n        \"\u041e\u0440\u0433\u0430\u043d\u0438\u0437\u0430\u0446\u0438\u044f&lt;br&gt;\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0433\u043e&lt;br&gt;\u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430\",\n    ]\n    return self._get_csi(new_colnames, csi_Qind)\n</code></pre>"},{"location":"references/backend/#app.backend.data_extractors.ExitEmbaExtractor.get_top_lectors","title":"<code>get_top_lectors(lectors_Qind=6)</code>","text":"<p>Returns a ranked count of most frequently selected lecturers. This method extracts responses from a specific question in the table.</p> <p>Parameters:</p> Name Type Description Default <code>lectors_Qind</code> <code>int</code> <p>Index of the lecturer evaluation question. Defaults to 6.</p> <code>6</code> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Dict[str, int]: Lecturer names mapped to selection counts.</p> Source code in <code>src/app/backend/data_extractors.py</code> <pre><code>def get_top_lectors(self, lectors_Qind: int = 6) -&gt; Dict[str, int]:\n    \"\"\"Returns a ranked count of most frequently selected lecturers.\n    This method extracts responses from a specific question in the table.\n\n    Args:\n        lectors_Qind (int, optional): Index of the lecturer evaluation question. Defaults to 6.\n\n    Returns:\n        Dict[str, int]: Lecturer names mapped to selection counts.\n    \"\"\"\n    lectors_cols = [\n        col for col in self.df.columns if col.startswith(f\"Q{lectors_Qind}\")\n    ]\n    all_lectors = self.df[lectors_cols]\n    mask_all_zeros = (all_lectors == 0).all(axis=1)\n    zeros_count = mask_all_zeros.sum()\n    lectors = all_lectors.loc[~mask_all_zeros, lectors_cols].values.flatten()\n    lectors = [lector for lector in lectors if lector != 0]\n    lectors_counts = pd.Series(lectors).value_counts()\n    lectors_counts[\"\u041d\u0438\u043a\u0442\u043e\"] = zeros_count\n    lectors_counts = lectors_counts.sort_values(ascending=True).to_dict()\n    return lectors_counts\n</code></pre>"},{"location":"references/backend/#app.backend.plotter","title":"<code>app.backend.plotter</code>","text":"<p>Classes for creating various plots.</p>"},{"location":"references/backend/#app.backend.plotter.PlotGenerator","title":"<code>PlotGenerator</code>","text":"<p>A utility class for generating various types of interactive plots using Plotly.</p> <p>This class provides reusable methods to construct common survey visualizations such as boxplots, pie charts, NPS barplots, horizontal barplots, and stacked barplots. It also includes helpers to add custom titles, background shapes, and dummy legends.</p> Class Attributes <p>title_template (dict): Default layout template for plot titles.</p> <p>rectangle_template (dict): Default template for background rectangle shapes.</p> <p>Methods:</p> Name Description <code>make_boxplot</code> <p>Generates a boxplot for grouped numerical data.</p> <code>make_piechart</code> <p>Creates a donut-style pie chart with total annotation.</p> <code>make_nps_barplot</code> <p>Builds a customized barplot for Net Promoter Score analysis.</p> <code>make_stacked_barplot</code> <p>Constructs a stacked barplot with weighted means.</p> <code>make_hbarplot</code> <p>Produces a horizontal barplot with color encoding.</p> Source code in <code>src/app/backend/plotter.py</code> <pre><code>class PlotGenerator:\n    \"\"\"A utility class for generating various types of interactive plots using Plotly.\n\n    This class provides reusable methods to construct common survey visualizations such\n    as boxplots, pie charts, NPS barplots, horizontal barplots, and stacked barplots. It\n    also includes helpers to add custom titles, background shapes, and dummy legends.\n\n    Class Attributes:\n        title_template (dict): Default layout template for plot titles.\n\n        rectangle_template (dict): Default template for background rectangle shapes.\n\n    Methods:\n        make_boxplot: Generates a boxplot for grouped numerical data.\n        make_piechart: Creates a donut-style pie chart with total annotation.\n        make_nps_barplot: Builds a customized barplot for Net Promoter Score analysis.\n        make_stacked_barplot: Constructs a stacked barplot with weighted means.\n        make_hbarplot: Produces a horizontal barplot with color encoding.\n    \"\"\"\n\n    title_template = {\n        \"text\": \"SAMPLE_TITLE\",\n        \"x\": 0.45,\n        \"xanchor\": \"center\",\n        \"y\": 0.9,\n        \"font\": dict(size=20),\n    }\n\n    rectangle_template = dict(\n        type=\"rect\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0,\n        x1=1,\n        y0=0,\n        y1=20,\n        fillcolor=\"SAMPLE COLOR\",\n        opacity=0.4,\n        line_width=0,\n    )\n\n    @classmethod\n    def _make_title(cls, title_text: str) -&gt; dict:\n        \"\"\"Create a plot title dictionary based on the class template.\n\n        Args:\n            title_text (str): The title text to display.\n\n        Returns:\n            dict: A dictionary representing the plot title layout.\n        \"\"\"\n        title = cls.title_template.copy()\n        title[\"text\"] = title_text\n        return title\n\n    # used in nps barplots as backgroud\n    @classmethod\n    def _edit_shape(cls, y0: int, y1: int, color: str) -&gt; dict:\n        \"\"\"Create a rectangular shape dictionary for plot background highlighting.\n\n        Args:\n            y0 (int): The lower bound on the y-axis.\n            y1 (int): The upper bound on the y-axis.\n            color (str): The fill color of the rectangle.\n\n        Returns:\n            dict: A dictionary representing the shape layout.\n        \"\"\"\n        shape = cls.rectangle_template.copy()\n        shape[\"fillcolor\"] = color\n        shape[\"y0\"] = y0\n        shape[\"y1\"] = y1\n        return shape\n\n    @staticmethod\n    def _make_legend(legend_text: str, color: str) -&gt; go.Scatter:\n        \"\"\"Create a dummy invisible scatter trace to serve as a custom legend item.\n\n        Args:\n            legend_text (str): The label text for the legend.\n            color (str): The marker color for the legend.\n\n        Returns:\n            go.Scatter: A Plotly scatter trace configured for the legend.\n        \"\"\"\n        dummy_legend = dict(\n            x=[None],\n            y=[None],\n            mode=\"markers\",\n            marker=dict(size=10, color=color, opacity=0.6),\n            name=legend_text,\n        )\n        invisible_fig = go.Scatter(dummy_legend)\n        return invisible_fig\n\n    @classmethod\n    def make_boxplot(cls, data: Dict[str, List[float]], title: str) -&gt; go.Figure:\n        \"\"\"Generate a boxplot figure with grouped data.\n\n        Args:\n            data (Dict[str, List[float]]): Dictionary mapping group names to numerical data.\n            title (str): Title of the plot.\n\n        Returns:\n            go.Figure: Plotly figure object with boxplot traces.\n        \"\"\"\n        fig = go.Figure()\n        for name in data.keys():\n            fig.add_trace(go.Box(y=data[name], name=name, boxmean=True))\n\n        fig.update_xaxes(tickangle=0)\n        fig.update_layout(title=cls._make_title(title))\n        return fig\n\n    @classmethod\n    def make_piechart(cls, data: Dict[str, float], title: str) -&gt; go.Figure:\n        \"\"\"Generate a donut-style pie chart with total value annotation.\n\n        Args:\n            data (Dict[str, float]): Dictionary mapping labels to values.\n            title (str): Title of the plot.\n\n        Returns:\n            go.Figure: Plotly figure object with a pie chart.\n        \"\"\"\n        total = sum(list(data.values()))\n        fig = go.Figure()\n        fig.add_trace(\n            go.Pie(labels=list(data.keys()), values=list(data.values()), name=title)\n        )\n        fig.update_traces(hole=0.4, hoverinfo=\"value+percent+label\")\n        fig.update_layout(\n            title=cls._make_title(title),\n            annotations=[\n                dict(\n                    text=f\"&lt;b&gt;{total}&lt;/b&gt;\", x=0.5, y=0.5, font_size=20, showarrow=False\n                )\n            ],\n        )\n        return fig\n\n    @classmethod\n    def make_nps_barplot(\n        cls, barnames: List[str], values: List[int], colors: List[str], title: str\n    ) -&gt; go.Figure:\n        \"\"\"Generate a Net Promoter Score (NPS) styled barplot with color-coded background.\n\n        Args:\n            barnames (List[str]): Names for each bar.\n            values (List[int]): Numerical values for each bar.\n            colors (List[str]): Colors corresponding to each bar.\n            title (str): Title of the plot.\n\n        Returns:\n            go.Figure: Plotly figure object with NPS barplot.\n        \"\"\"\n        fig = go.Figure()\n        fig.add_trace(\n            go.Bar(\n                x=barnames,\n                y=values,\n                showlegend=False,\n                name=\"\",\n                marker=dict(color=colors),\n            )\n        )\n        fig.add_traces(\n            [\n                cls._make_legend(\"Good (by Bain&amp;Company)\", color=\"#b2df8a\"),\n                cls._make_legend(\"Favorable (by Bain&amp;Company)\", color=\"#66bb6a\"),\n                cls._make_legend(\"Excellent (by Bain&amp;Company)\", color=\"#388e3c\"),\n                cls._make_legend(\"World class (by Bain&amp;Company)\", color=\"#1b5e20\"),\n            ]\n        )\n        fig.update_layout(\n            height=600,\n            title=cls._make_title(title),\n            yaxis=dict(range=[-100, 100]),\n            shapes=[\n                cls._edit_shape(y0=0, y1=20, color=\"#b2df8a\"),\n                cls._edit_shape(y0=20, y1=50, color=\"#66bb6a\"),\n                cls._edit_shape(y0=50, y1=80, color=\"#388e3c\"),\n                cls._edit_shape(y0=80, y1=100, color=\"#1b5e20\"),\n            ],\n        )\n        return fig\n\n    @classmethod\n    def make_stacked_barplot(\n        cls,\n        score_counts: pd.DataFrame,\n        title: str,\n        x_axs_title: str = \"x\",\n        y_axs_title: str = \"y\",\n    ) -&gt; go.Figure:\n        \"\"\"Generate a stacked barplot with color-coded scores and weighted mean annotations.\n\n        Args:\n            score_counts (pd.DataFrame): DataFrame containing counts per score per category.\n            title (str): Title of the plot.\n            x_axs_title (str, optional): Label for the x-axis. Defaults to \"x\".\n            y_axs_title (str, optional): Label for the y-axis. Defaults to \"y\".\n\n        Returns:\n            go.Figure: Plotly figure object with stacked barplot.\n        \"\"\"\n        fig = go.Figure()\n        colors = sample_colorscale(\"RdYlGn\", [i / 9 for i in range(10)])\n        for score in range(1, 11):\n            fig.add_trace(\n                go.Bar(\n                    x=score_counts[\"param\"],\n                    y=score_counts[score],\n                    name=str(score),\n                    marker_color=colors[score - 1],\n                )\n            )\n\n        # calculate weighted means for each bar\n        scores = np.arange(1, 11)\n        counts = score_counts.loc[:, 1:10].values  # [n_categories, 10]\n        weighted_means = (counts * scores).sum(axis=1) / counts.sum(axis=1)\n\n        fig.add_trace(\n            go.Scatter(\n                x=score_counts[\"param\"],\n                y=counts.sum(axis=1) + 0.5,\n                mode=\"text\",\n                text=[f\"{wm:.2f}\" for wm in weighted_means],\n                textposition=\"top center\",\n                showlegend=False,\n                hovertemplate=\"\u0421\u0440\u0435\u0434\u043d\u0435\u0435&lt;extra&gt;&lt;/extra&gt;\",\n            )\n        )\n\n        fig.update_layout(\n            height=600,\n            title=cls._make_title(title),\n            barmode=\"stack\",\n            xaxis_title=x_axs_title,\n            yaxis_title=y_axs_title,\n        )\n        fig.update_xaxes(tickangle=270)\n        return fig\n\n    @classmethod\n    def make_hbarplot(\n        cls,\n        score_counts: Dict[str, int],\n        title: str,\n        x_axs_title: str = \"x\",\n        y_axs_title: str = \"y\",\n    ) -&gt; go.Figure:\n        \"\"\"Generate a horizontal barplot with color-coded bars based on values.\n\n        Args:\n            score_counts (Dict[str, int]): Dictionary mapping categories to values.\n            title (str): Title of the plot.\n            x_axs_title (str, optional): Label for the x-axis. Defaults to \"x\".\n            y_axs_title (str, optional): Label for the y-axis. Defaults to \"y\".\n\n        Returns:\n            go.Figure: Plotly figure object with horizontal barplot.\n        \"\"\"\n        fig = go.Figure()\n        num_colors = len(set(score_counts.values()))\n        palette = sample_colorscale(\n            \"Greens\", [i / (num_colors - 1) for i in range(num_colors)]\n        )\n        votes_to_colors = dict(zip(sorted(set(score_counts.values())), palette))\n        scores_colors = [votes_to_colors[i] for i in score_counts.values()]\n        fig.add_trace(\n            go.Bar(\n                x=list(score_counts.values()),\n                y=list(score_counts.keys()),\n                marker_color=scores_colors,\n                orientation=\"h\",\n            )\n        )\n        fig.update_layout(\n            height=600,\n            title=cls._make_title(title),\n            barmode=\"stack\",\n            xaxis_title=x_axs_title,\n            yaxis_title=y_axs_title,\n        )\n\n        return fig\n</code></pre>"},{"location":"references/backend/#app.backend.plotter.PlotGenerator.make_boxplot","title":"<code>make_boxplot(data, title)</code>  <code>classmethod</code>","text":"<p>Generate a boxplot figure with grouped data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, List[float]]</code> <p>Dictionary mapping group names to numerical data.</p> required <code>title</code> <code>str</code> <p>Title of the plot.</p> required <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: Plotly figure object with boxplot traces.</p> Source code in <code>src/app/backend/plotter.py</code> <pre><code>@classmethod\ndef make_boxplot(cls, data: Dict[str, List[float]], title: str) -&gt; go.Figure:\n    \"\"\"Generate a boxplot figure with grouped data.\n\n    Args:\n        data (Dict[str, List[float]]): Dictionary mapping group names to numerical data.\n        title (str): Title of the plot.\n\n    Returns:\n        go.Figure: Plotly figure object with boxplot traces.\n    \"\"\"\n    fig = go.Figure()\n    for name in data.keys():\n        fig.add_trace(go.Box(y=data[name], name=name, boxmean=True))\n\n    fig.update_xaxes(tickangle=0)\n    fig.update_layout(title=cls._make_title(title))\n    return fig\n</code></pre>"},{"location":"references/backend/#app.backend.plotter.PlotGenerator.make_hbarplot","title":"<code>make_hbarplot(score_counts, title, x_axs_title='x', y_axs_title='y')</code>  <code>classmethod</code>","text":"<p>Generate a horizontal barplot with color-coded bars based on values.</p> <p>Parameters:</p> Name Type Description Default <code>score_counts</code> <code>Dict[str, int]</code> <p>Dictionary mapping categories to values.</p> required <code>title</code> <code>str</code> <p>Title of the plot.</p> required <code>x_axs_title</code> <code>str</code> <p>Label for the x-axis. Defaults to \"x\".</p> <code>'x'</code> <code>y_axs_title</code> <code>str</code> <p>Label for the y-axis. Defaults to \"y\".</p> <code>'y'</code> <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: Plotly figure object with horizontal barplot.</p> Source code in <code>src/app/backend/plotter.py</code> <pre><code>@classmethod\ndef make_hbarplot(\n    cls,\n    score_counts: Dict[str, int],\n    title: str,\n    x_axs_title: str = \"x\",\n    y_axs_title: str = \"y\",\n) -&gt; go.Figure:\n    \"\"\"Generate a horizontal barplot with color-coded bars based on values.\n\n    Args:\n        score_counts (Dict[str, int]): Dictionary mapping categories to values.\n        title (str): Title of the plot.\n        x_axs_title (str, optional): Label for the x-axis. Defaults to \"x\".\n        y_axs_title (str, optional): Label for the y-axis. Defaults to \"y\".\n\n    Returns:\n        go.Figure: Plotly figure object with horizontal barplot.\n    \"\"\"\n    fig = go.Figure()\n    num_colors = len(set(score_counts.values()))\n    palette = sample_colorscale(\n        \"Greens\", [i / (num_colors - 1) for i in range(num_colors)]\n    )\n    votes_to_colors = dict(zip(sorted(set(score_counts.values())), palette))\n    scores_colors = [votes_to_colors[i] for i in score_counts.values()]\n    fig.add_trace(\n        go.Bar(\n            x=list(score_counts.values()),\n            y=list(score_counts.keys()),\n            marker_color=scores_colors,\n            orientation=\"h\",\n        )\n    )\n    fig.update_layout(\n        height=600,\n        title=cls._make_title(title),\n        barmode=\"stack\",\n        xaxis_title=x_axs_title,\n        yaxis_title=y_axs_title,\n    )\n\n    return fig\n</code></pre>"},{"location":"references/backend/#app.backend.plotter.PlotGenerator.make_nps_barplot","title":"<code>make_nps_barplot(barnames, values, colors, title)</code>  <code>classmethod</code>","text":"<p>Generate a Net Promoter Score (NPS) styled barplot with color-coded background.</p> <p>Parameters:</p> Name Type Description Default <code>barnames</code> <code>List[str]</code> <p>Names for each bar.</p> required <code>values</code> <code>List[int]</code> <p>Numerical values for each bar.</p> required <code>colors</code> <code>List[str]</code> <p>Colors corresponding to each bar.</p> required <code>title</code> <code>str</code> <p>Title of the plot.</p> required <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: Plotly figure object with NPS barplot.</p> Source code in <code>src/app/backend/plotter.py</code> <pre><code>@classmethod\ndef make_nps_barplot(\n    cls, barnames: List[str], values: List[int], colors: List[str], title: str\n) -&gt; go.Figure:\n    \"\"\"Generate a Net Promoter Score (NPS) styled barplot with color-coded background.\n\n    Args:\n        barnames (List[str]): Names for each bar.\n        values (List[int]): Numerical values for each bar.\n        colors (List[str]): Colors corresponding to each bar.\n        title (str): Title of the plot.\n\n    Returns:\n        go.Figure: Plotly figure object with NPS barplot.\n    \"\"\"\n    fig = go.Figure()\n    fig.add_trace(\n        go.Bar(\n            x=barnames,\n            y=values,\n            showlegend=False,\n            name=\"\",\n            marker=dict(color=colors),\n        )\n    )\n    fig.add_traces(\n        [\n            cls._make_legend(\"Good (by Bain&amp;Company)\", color=\"#b2df8a\"),\n            cls._make_legend(\"Favorable (by Bain&amp;Company)\", color=\"#66bb6a\"),\n            cls._make_legend(\"Excellent (by Bain&amp;Company)\", color=\"#388e3c\"),\n            cls._make_legend(\"World class (by Bain&amp;Company)\", color=\"#1b5e20\"),\n        ]\n    )\n    fig.update_layout(\n        height=600,\n        title=cls._make_title(title),\n        yaxis=dict(range=[-100, 100]),\n        shapes=[\n            cls._edit_shape(y0=0, y1=20, color=\"#b2df8a\"),\n            cls._edit_shape(y0=20, y1=50, color=\"#66bb6a\"),\n            cls._edit_shape(y0=50, y1=80, color=\"#388e3c\"),\n            cls._edit_shape(y0=80, y1=100, color=\"#1b5e20\"),\n        ],\n    )\n    return fig\n</code></pre>"},{"location":"references/backend/#app.backend.plotter.PlotGenerator.make_piechart","title":"<code>make_piechart(data, title)</code>  <code>classmethod</code>","text":"<p>Generate a donut-style pie chart with total value annotation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, float]</code> <p>Dictionary mapping labels to values.</p> required <code>title</code> <code>str</code> <p>Title of the plot.</p> required <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: Plotly figure object with a pie chart.</p> Source code in <code>src/app/backend/plotter.py</code> <pre><code>@classmethod\ndef make_piechart(cls, data: Dict[str, float], title: str) -&gt; go.Figure:\n    \"\"\"Generate a donut-style pie chart with total value annotation.\n\n    Args:\n        data (Dict[str, float]): Dictionary mapping labels to values.\n        title (str): Title of the plot.\n\n    Returns:\n        go.Figure: Plotly figure object with a pie chart.\n    \"\"\"\n    total = sum(list(data.values()))\n    fig = go.Figure()\n    fig.add_trace(\n        go.Pie(labels=list(data.keys()), values=list(data.values()), name=title)\n    )\n    fig.update_traces(hole=0.4, hoverinfo=\"value+percent+label\")\n    fig.update_layout(\n        title=cls._make_title(title),\n        annotations=[\n            dict(\n                text=f\"&lt;b&gt;{total}&lt;/b&gt;\", x=0.5, y=0.5, font_size=20, showarrow=False\n            )\n        ],\n    )\n    return fig\n</code></pre>"},{"location":"references/backend/#app.backend.plotter.PlotGenerator.make_stacked_barplot","title":"<code>make_stacked_barplot(score_counts, title, x_axs_title='x', y_axs_title='y')</code>  <code>classmethod</code>","text":"<p>Generate a stacked barplot with color-coded scores and weighted mean annotations.</p> <p>Parameters:</p> Name Type Description Default <code>score_counts</code> <code>DataFrame</code> <p>DataFrame containing counts per score per category.</p> required <code>title</code> <code>str</code> <p>Title of the plot.</p> required <code>x_axs_title</code> <code>str</code> <p>Label for the x-axis. Defaults to \"x\".</p> <code>'x'</code> <code>y_axs_title</code> <code>str</code> <p>Label for the y-axis. Defaults to \"y\".</p> <code>'y'</code> <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: Plotly figure object with stacked barplot.</p> Source code in <code>src/app/backend/plotter.py</code> <pre><code>@classmethod\ndef make_stacked_barplot(\n    cls,\n    score_counts: pd.DataFrame,\n    title: str,\n    x_axs_title: str = \"x\",\n    y_axs_title: str = \"y\",\n) -&gt; go.Figure:\n    \"\"\"Generate a stacked barplot with color-coded scores and weighted mean annotations.\n\n    Args:\n        score_counts (pd.DataFrame): DataFrame containing counts per score per category.\n        title (str): Title of the plot.\n        x_axs_title (str, optional): Label for the x-axis. Defaults to \"x\".\n        y_axs_title (str, optional): Label for the y-axis. Defaults to \"y\".\n\n    Returns:\n        go.Figure: Plotly figure object with stacked barplot.\n    \"\"\"\n    fig = go.Figure()\n    colors = sample_colorscale(\"RdYlGn\", [i / 9 for i in range(10)])\n    for score in range(1, 11):\n        fig.add_trace(\n            go.Bar(\n                x=score_counts[\"param\"],\n                y=score_counts[score],\n                name=str(score),\n                marker_color=colors[score - 1],\n            )\n        )\n\n    # calculate weighted means for each bar\n    scores = np.arange(1, 11)\n    counts = score_counts.loc[:, 1:10].values  # [n_categories, 10]\n    weighted_means = (counts * scores).sum(axis=1) / counts.sum(axis=1)\n\n    fig.add_trace(\n        go.Scatter(\n            x=score_counts[\"param\"],\n            y=counts.sum(axis=1) + 0.5,\n            mode=\"text\",\n            text=[f\"{wm:.2f}\" for wm in weighted_means],\n            textposition=\"top center\",\n            showlegend=False,\n            hovertemplate=\"\u0421\u0440\u0435\u0434\u043d\u0435\u0435&lt;extra&gt;&lt;/extra&gt;\",\n        )\n    )\n\n    fig.update_layout(\n        height=600,\n        title=cls._make_title(title),\n        barmode=\"stack\",\n        xaxis_title=x_axs_title,\n        yaxis_title=y_axs_title,\n    )\n    fig.update_xaxes(tickangle=270)\n    return fig\n</code></pre>"},{"location":"references/backend/#app.backend.raw_data_processor","title":"<code>app.backend.raw_data_processor</code>","text":"<p>Add classes and funtioncs for processing raw survey tables here.</p>"},{"location":"references/backend/#app.backend.raw_data_processor.process_exit_survey","title":"<code>process_exit_survey(raw_table)</code>","text":"<p>Cleans and preprocesses raw exit survey data from an Excel file or stream.</p> <p>The function performs the following steps: - Loads the Excel data, skipping header rows. - Drops irrelevant columns including service and unnamed columns. - Removes rows missing participant names. - Fills missing professor names with a placeholder. - Imputes missing ages with the median age. - Fills missing scores in selected columns with column means. - Sets default text for missing answers in specified free-answer columns. - Returns the cleaned data as an in-memory Excel file stream.</p> <p>Parameters:</p> Name Type Description Default <code>raw_table</code> <code>str | IO</code> <p>Path to the Excel file or file-like object containing raw survey data.</p> required <p>Returns:</p> Name Type Description <code>BytesIO</code> <code>BytesIO</code> <p>In-memory binary stream containing the cleaned Excel data.</p> Source code in <code>src/app/backend/raw_data_processor.py</code> <pre><code>def process_exit_survey(raw_table: str | IO) -&gt; BytesIO:\n    \"\"\"Cleans and preprocesses raw exit survey data from an Excel file or stream.\n\n    The function performs the following steps:\n    - Loads the Excel data, skipping header rows.\n    - Drops irrelevant columns including service and unnamed columns.\n    - Removes rows missing participant names.\n    - Fills missing professor names with a placeholder.\n    - Imputes missing ages with the median age.\n    - Fills missing scores in selected columns with column means.\n    - Sets default text for missing answers in specified free-answer columns.\n    - Returns the cleaned data as an in-memory Excel file stream.\n\n    Args:\n        raw_table (str | IO): Path to the Excel file or file-like object containing raw survey data.\n\n    Returns:\n        BytesIO: In-memory binary stream containing the cleaned Excel data.\n    \"\"\"\n    raw_data = pd.read_excel(raw_table, skiprows=[0, 2, 3])\n\n    service_cols = [col for col in raw_data.columns if col.startswith(\"S\")]\n    unnamed_cols = [col for col in raw_data.columns if col.startswith(\"Unnamed:\")]\n    cols_to_drop = [\"PS0 Start\", \"PD0 Duration , sec\"] + service_cols + unnamed_cols\n    raw_data = raw_data.drop(columns=cols_to_drop)\n\n    # drop all rows where participant name is None\n    name_col = \"Q16  - \ud83d\udd34 \u0423\u043a\u0430\u0436\u0438\u0442\u0435  \u0444\u0430\u043c\u0438\u043b\u0438\u044e \u0438 \u0438\u043c\u044f\"\n    q6_cols = [col for col in raw_data.columns if col.startswith(\"Q6\")]\n    raw_data = raw_data.dropna(subset=[name_col], ignore_index=True)\n\n    # if a student doesnt remember any professors\n    raw_data[q6_cols] = raw_data[q6_cols].fillna(\"\u041d\u0438\u043a\u0442\u043e\")\n\n    # if the age was not provided fill with mode\n    age_col = \"Q15 \ud83d\udd34  \u0423\u043a\u0430\u0436\u0438\u0442\u0435 \u0432\u0430\u0448  \u0432\u043e\u0437\u0440\u0430\u0441\u0442\"\n    raw_data[age_col] = raw_data[age_col].fillna(raw_data[age_col].median())\n\n    score_cols = [\n        col\n        for col in raw_data.columns\n        if col.startswith(\"Q7\") or col.startswith(\"Q8\") or col.startswith(\"Q9\")\n    ]\n    # if a value in scoring col is missing, replace by the mean\n    for col in score_cols:\n        raw_data[col] = raw_data[col].fillna(int(raw_data[col].mean()))\n\n    free_answer_cols = [\n        \"Q4.1 \u041a\u0430\u043a\u043e\u0432\u044b, \u043d\u0430 \u0432\u0430\u0448 \u0432\u0437\u0433\u043b\u044f\u0434,  \u0441\u0438\u043b\u044c\u043d\u044b\u0435 \u0438 \u0441\u043b\u0430\u0431\u044b\u0435 \u0441\u0442\u043e\u0440\u043e\u043d\u044b \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b? - \u0421\u0438\u043b\u044c\u043d\u044b\u0435 \u0441\u0442\u043e\u0440\u043e\u043d\u044b\",\n        \"Q4.2 \u041a\u0430\u043a\u043e\u0432\u044b, \u043d\u0430 \u0432\u0430\u0448 \u0432\u0437\u0433\u043b\u044f\u0434,  \u0441\u0438\u043b\u044c\u043d\u044b\u0435 \u0438 \u0441\u043b\u0430\u0431\u044b\u0435 \u0441\u0442\u043e\u0440\u043e\u043d\u044b \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b? - \u0421\u043b\u0430\u0431\u044b\u0435 \u0441\u0442\u043e\u0440\u043e\u043d\u044b\",\n        \"Q10 \u041e\u0441\u0442\u0430\u0432\u044c\u0442\u0435 \u0432\u0430\u0448\u0438  \u043f\u043e\u0436\u0435\u043b\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0438  \u043f\u043e \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0435\",\n        \"Q10 \u041e\u0441\u0442\u0430\u0432\u044c\u0442\u0435 \u0432\u0430\u0448\u0438  \u043f\u043e\u0436\u0435\u043b\u0430\u043d\u0438\u044f \u0438 \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0438  \u043f\u043e \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0435\",\n        \"Q11.1.O \u0412 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u043f\u0440\u0438\u0433\u043b\u0430\u0448\u0435\u043d\u043d\u043e\u0433\u043e \u0441\u043f\u0438\u043a\u0435\u0440\u0430 - \u0431\u0440\u0435\u043d\u0434\u0438\u043d\u0433, \u043a\u043e\u0440\u043f\u0444\u0438\u043d\",\n        \"Q11.5.O \u0414\u0440\u0443\u0433\u043e\u0435 - \u043f\u0440\u043e\u0442\u0430\u0433\u043e\u043d\u0438\u0441\u0442 \u043a\u0435\u0439\u0441\u0430\",\n        \"Q13.6.O \u0414\u0440\u0443\u0433\u043e\u0435 - Other\",\n        \"Q14.20.O \u0414\u0440\u0443\u0433\u043e\u0435 - Other\",\n    ]\n    # set to \"No comments\" if the answer wasnt provided in cols with free answer\n    for col in free_answer_cols:\n        raw_data[col] = raw_data[col].fillna(\"No comments\")\n\n    # save to stream\n    buf = BytesIO()\n    raw_data.to_excel(buf, index=False)\n    buf.seek(0)\n    return buf\n</code></pre>"},{"location":"references/main_page/","title":"App main page","text":""},{"location":"references/main_page/#appemba_exit_dashboard-source-code","title":"<code>app.emba_exit_dashboard</code> Source Code","text":"<pre><code>\"\"\"Rendering the main page of an report app.\"\"\"\n\nimport streamlit as st\nfrom backend.data_extractors import ExitEmbaExtractor\nfrom backend.raw_data_processor import process_exit_survey\n\nfrom app.sections import (\n    base_distributions,\n    download,\n    grades_analysis,\n    nps,\n    other,\n    pilos,\n)\n\n# Page config\nst.set_page_config(page_title=\"EMBA-35 report\", layout=\"wide\")\nst.markdown(\n    \"\"\"\n    ## \u041e\u0442\u0447\u0435\u0442 EMBA-35\n&lt;div style='font-size:18px'&gt;\n    \u041e\u043f\u0440\u043e\u0441 \u043f\u0440\u043e\u0432\u043e\u0434\u0438\u0442\u0441\u044f \u043f\u043e\u0441\u043b\u0435 \u0438\u0442\u043e\u0433\u043e\u0432\u043e\u0439 \u0430\u0442\u0442\u0435\u0441\u0442\u0430\u0446\u0438\u0438 \u0441\u0440\u0435\u0434\u0438 \u0441\u0442\u0443\u0434\u0435\u043d\u0442\u043e\u0432, \u0437\u0430\u0432\u0435\u0440\u0448\u0438\u0432\u0448\u0438\u0445 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u0435.&lt;br&gt;\n    \u041e\u043d \u0432\u043a\u043b\u044e\u0447\u0430\u0435\u0442 &lt;strong&gt;15&lt;/strong&gt; \u0432\u043e\u043f\u0440\u043e\u0441\u043e\u0432 \u043e\u0431 \u043e\u0446\u0435\u043d\u043a\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b, \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432, \u043a\u043e\u043c\u0430\u043d\u0434\u044b \u0438 \u043f\u0440\u0435\u0434\u043f\u043e\u0447\u0442\u0435\u043d\u0438\u044f\u0445 \u0432 \u043e\u0431\u0449\u0435\u043d\u0438\u0438 \u0441\u043e \u0428\u043a\u043e\u043b\u043e\u0439.&lt;br&gt;\n    &lt;strong&gt;\u0426\u0435\u043b\u044c:&lt;/strong&gt; \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043e\u0431\u0440\u0430\u0442\u043d\u0443\u044e \u0441\u0432\u044f\u0437\u044c \u0432\u044b\u043f\u0443\u0441\u043a\u043d\u0438\u043a\u043e\u0432 \u0434\u043b\u044f \u0443\u043b\u0443\u0447\u0448\u0435\u043d\u0438\u044f \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0432 \u043c\u0430\u0440\u043a\u0435\u0442\u0438\u043d\u0433\u0435, \u043f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0438 \u0430\u043a\u043a\u0440\u0435\u0434\u0438\u0442\u0430\u0446\u0438\u043e\u043d\u043d\u043e\u0439 \u043e\u0442\u0447\u0451\u0442\u043d\u043e\u0441\u0442\u0438.&lt;br&gt;&lt;br&gt;\n&lt;/div&gt;\n\"\"\",\n    unsafe_allow_html=True,\n)\n\n# Sidebar\nst.sidebar.title(\"\u0424\u0438\u043b\u044c\u0442\u0440\u044b\")\nwith st.sidebar:\n    section_types = st.multiselect(\n        label=\"\u041f\u043e \u0440\u0430\u0437\u0434\u0435\u043b\u0430\u043c:\",\n        options=[\n            \"\u0411\u0430\u0437\u043e\u0432\u044b\u0435 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044f\",\n            \"\u0410\u043d\u0430\u043b\u0438\u0437 \u043e\u0446\u0435\u043d\u043e\u043a\",\n            \"NPS\",\n            \"PILOs\",\n            \"\u041f\u0440\u043e\u0447\u0438\u0435 \u0433\u0440\u0430\u0444\u0438\u043a\u0438\",\n            \"\u0421\u043a\u0430\u0447\u0430\u0442\u044c \u043e\u0442\u0447\u0435\u0442\",\n        ],\n    )\n\n# File loader\nexcel_file = st.file_uploader(\n    label=\"\u0417\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u0435 excel-\u0444\u0430\u0439\u043b \u0441 \u043e\u043f\u0440\u043e\u0441\u043e\u043c \u043f\u043e \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0435 EMBA-35\",\n    type=[\"xls\", \"xlsx\"],\n    key=\"competencies_excel\",\n    accept_multiple_files=False,\n)\n\n# File processing (in back)\nif \"survey_processed\" not in st.session_state:\n    st.session_state.survey_processed = False\n\nif excel_file and not st.session_state.survey_processed:\n    processed_file = process_exit_survey(excel_file)\n    emba_extractor = ExitEmbaExtractor(processed_file)\n    st.session_state.emba_extractor = emba_extractor\n    st.session_state.survey_processed = True\n\n# Results (main render)\nif st.session_state.survey_processed:\n    emba_extractor = st.session_state.emba_extractor\n    if \"\u0411\u0430\u0437\u043e\u0432\u044b\u0435 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044f\" in section_types:\n        base_distributions.render(emba_extractor)\n    if \"\u0410\u043d\u0430\u043b\u0438\u0437 \u043e\u0446\u0435\u043d\u043e\u043a\" in section_types:\n        grades_analysis.render(emba_extractor)\n    if \"NPS\" in section_types:\n        nps.render(emba_extractor)\n    if \"PILOs\" in section_types:\n        pilos.render(emba_extractor)\n    if \"\u041f\u0440\u043e\u0447\u0438\u0435 \u0433\u0440\u0430\u0444\u0438\u043a\u0438\" in section_types:\n        other.render(emba_extractor)\n    if \"\u0421\u043a\u0430\u0447\u0430\u0442\u044c \u043e\u0442\u0447\u0435\u0442\" in section_types:\n        if st.button(\"\u0421\u043a\u0430\u0447\u0430\u0442\u044c \u043e\u0442\u0447\u0435\u0442\"):\n            docx_path = download.generate_docx(emba_extractor)\n    if \"Pairings\" in section_types:\n        st.header(\"Pairings\")\n        st.markdown(\"#### Coming soon...\")\n        other.render(emba_extractor)\n    if \"\u0421\u043a\u0430\u0447\u0430\u0442\u044c \u043e\u0442\u0447\u0435\u0442\" in section_types:\n        if st.button(\"\u0421\u043a\u0430\u0447\u0430\u0442\u044c \u043e\u0442\u0447\u0435\u0442\"):\n            docx_path = download.generate_docx(emba_extractor)\n    if \"Pairings\" in section_types:\n        st.header(\"Pairings\")\n        st.markdown(\"#### Coming soon...\")\n</code></pre>"},{"location":"references/sections/","title":"App sections","text":""},{"location":"references/sections/#app.sections.base_distributions","title":"<code>app.sections.base_distributions</code>","text":""},{"location":"references/sections/#app.sections.base_distributions.render","title":"<code>render(emba_extractor)</code>","text":"<p>Render pie charts showing basic demographic distributions of EMBA survey respondents using Streamlit.</p> <p>Displays: - Age distribution of students. - Distribution of students across industries. - Distribution of students by job positions. Args:     emba_extractor (ExitEmbaExtractor): Object that provides preprocessed survey data for visualization.</p> Source code in <code>src/app/sections/base_distributions.py</code> <pre><code>def render(emba_extractor: ExitEmbaExtractor) -&gt; None:\n    \"\"\"Render pie charts showing basic demographic distributions of EMBA survey respondents using Streamlit.\n\n    Displays:\n    - Age distribution of students.\n    - Distribution of students across industries.\n    - Distribution of students by job positions.\n    Args:\n        emba_extractor (ExitEmbaExtractor): Object that provides preprocessed survey data for visualization.\n    \"\"\"\n    st.header(\"\u0411\u0430\u0437\u043e\u0432\u044b\u0435 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044f\")\n\n    def _render_pie(title: str, data: Union[pd.DataFrame, pd.Series]) -&gt; None:\n        \"\"\"Helper function to render a pie chart within an expandable section.\n\n        Args:\n            title (str): Title of the chart and expander.\n            data (Union[pd.DataFrame, pd.Series]): Dictionary where keys are labels and values are counts.\n        \"\"\"\n        fig = PlotGenerator.make_piechart(data=data, title=title)\n        with st.expander(title):\n            st.plotly_chart(fig, use_container_width=True)\n\n    _render_pie(\"\u0420\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u043e\u0432\", emba_extractor.get_age_distr())\n    _render_pie(\n        \"\u0420\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0441\u0442\u0443\u0434\u0435\u043d\u0442\u043e\u0432 \u043f\u043e \u0438\u043d\u0434\u0443\u0441\u0442\u0440\u0438\u044f\u043c\", emba_extractor.get_industry_distr()\n    )\n    _render_pie(\n        \"\u0420\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0441\u0442\u0443\u0434\u0435\u043d\u0442\u043e\u0432 \u043f\u043e \u0437\u0430\u043d\u0438\u043c\u0430\u0435\u043c\u044b\u043c \u0434\u043e\u043b\u0436\u043d\u043e\u0441\u0442\u044f\u043c\",\n        emba_extractor.get_job_distr(),\n    )\n</code></pre>"},{"location":"references/sections/#app.sections.download","title":"<code>app.sections.download</code>","text":"<p>Section for saving a report into .docx file.</p>"},{"location":"references/sections/#app.sections.download.create_all_plots","title":"<code>create_all_plots(emba_extractor)</code>","text":"<p>Generate all survey-related visualizations as Plotly figures.</p> <p>Parameters:</p> Name Type Description Default <code>emba_extractor</code> <code>ExitEmbaExtractor</code> <p>Extractor providing necessary data.</p> required <p>Returns:</p> Type Description <code>List[Figure]</code> <p>List[go.Figure]: List of Plotly figures representing the generated plots.</p> Source code in <code>src/app/sections/download.py</code> <pre><code>def create_all_plots(emba_extractor: ExitEmbaExtractor) -&gt; List[go.Figure]:\n    \"\"\"Generate all survey-related visualizations as Plotly figures.\n\n    Args:\n        emba_extractor (ExitEmbaExtractor): Extractor providing necessary data.\n\n    Returns:\n        List[go.Figure]: List of Plotly figures representing the generated plots.\n    \"\"\"\n\n    def _create_pie(title: str, data: Union[pd.Dataframe, pd.Series]) -&gt; go.Figure:\n        \"\"\"Create a pie chart with qualitative color palette.\n\n        Args:\n            title (str): Title of the plot.\n            data (Union[pd.Dataframe, pd.Series]): Data to plot.\n\n        Returns:\n            go.Figure: Plotly pie chart figure.\n        \"\"\"\n        fig = PlotGenerator.make_piechart(data=data, title=title)\n\n        labels = fig.data[0].labels\n        color_list = qualitative.Set1 + qualitative.Set2 + qualitative.Set3\n        fig.data[0].marker.colors = color_list[: len(labels)]\n        return fig\n\n    def _create_boxplot(title: str, data: Union[pd.Dataframe, pd.Series]) -&gt; go.Figure:\n        \"\"\"Create a colored boxplot.\n\n        Args:\n            title (str): Title of the plot.\n            data (Union[pd.Dataframe, pd.Series]): Data to plot.\n\n        Returns:\n            go.Figure: Plotly boxplot figure.\n        \"\"\"\n        fig = PlotGenerator.make_boxplot(data=data, title=title)\n        for i, trace in enumerate(fig.data):\n            trace.marker.color = qualitative.D3[i % len(qualitative.D3)]\n            trace.line.color = trace.marker.color\n        return fig\n\n    def _create_nps(\n        title: str, barnames: list[str], values: list[float], colors: list[str]\n    ) -&gt; go.Figure:\n        \"\"\"Create a Net Promoter Score (NPS) bar plot.\n\n        Args:\n            title (str): Plot title.\n            barnames (list[str]): Labels for bars.\n            values (list[float]): Values for each bar.\n            colors (list[str]): Bar colors.\n\n        Returns:\n            go.Figure: Plotly barplot figure.\n        \"\"\"\n        fig = PlotGenerator.make_nps_barplot(\n            barnames=barnames, values=values, colors=colors, title=title\n        )\n        return fig\n\n    def _create_stacked_bar(\n        title: str, data: Union[pd.Dataframe, pd.Series]\n    ) -&gt; go.Figure:\n        \"\"\"Create a stacked bar plot for scores.\n\n        Args:\n            title (str): Plot title.\n            data (Union[pd.Dataframe, pd.Series]): Score distribution data.\n\n        Returns:\n            go.Figure: Plotly stacked bar chart.\n        \"\"\"\n        fig = PlotGenerator.make_stacked_barplot(\n            score_counts=data,\n            title=title,\n            x_axs_title=\"\u041f\u0440\u0435\u0434\u043c\u0435\u0442\",\n            y_axs_title=\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0441\u0442\u0443\u0434\u0435\u043d\u0442\u043e\u0432\",\n        )\n        return fig\n\n    def _create_hbar(\n        title: str,\n        data: Union[pd.Dataframe, pd.Series],\n        x_axs_title: str,\n        y_axs_title: str,\n    ) -&gt; go.Figure:\n        \"\"\"Create a horizontal bar plot.\n\n        Args:\n            title (str): Plot title.\n            data (Union[pd.Dataframe, pd.Series]): Data for plotting.\n            x_axs_title (str): Label for X-axis.\n            y_axs_title (str): Label for Y-axis.\n\n        Returns:\n            go.Figure: Plotly horizontal bar chart.\n        \"\"\"\n        fig = PlotGenerator.make_hbarplot(\n            score_counts=data,\n            title=title,\n            x_axs_title=x_axs_title,\n            y_axs_title=y_axs_title,\n        )\n        return fig\n\n    figs = []\n    figs.append(_create_pie(\"\u0420\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u043e\u0432\", emba_extractor.get_age_distr()))\n    figs.append(\n        _create_pie(\n            \"\u0420\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0441\u0442\u0443\u0434\u0435\u043d\u0442\u043e\u0432 \u043f\u043e \u0438\u043d\u0434\u0443\u0441\u0442\u0440\u0438\u044f\u043c\", emba_extractor.get_industry_distr()\n        )\n    )\n    figs.append(\n        _create_pie(\n            \"\u0420\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0441\u0442\u0443\u0434\u0435\u043d\u0442\u043e\u0432 \u043f\u043e \u0437\u0430\u043d\u0438\u043c\u0430\u0435\u043c\u044b\u043c \u0434\u043e\u043b\u0436\u043d\u043e\u0441\u0442\u044f\u043c\",\n            emba_extractor.get_job_distr(),\n        )\n    )\n    figs.append(\n        _create_boxplot(\"\u041e\u0446\u0435\u043d\u043a\u0430 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u0432 \u0446\u0435\u043b\u043e\u043c\", emba_extractor.get_basic_csi())\n    )\n    figs.append(\n        _create_boxplot(\n            \"\u0420\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043e\u0446\u0435\u043d\u043e\u043a \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u0441\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u044e\u0449\u0438\u0445 \u043a\u0443\u0440\u0441\u0430\",\n            emba_extractor.get_overall_csi(),\n        )\n    )\n    figs.append(\n        _create_boxplot(\"\u041e\u0446\u0435\u043d\u043a\u0430 \u0434\u0438\u0437\u0430\u0439\u043d\u0430 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b\", emba_extractor.get_design_csi())\n    )\n    figs.append(\n        _create_boxplot(\n            \"\u041e\u0446\u0435\u043d\u043a\u0430 \u043c\u0435\u0436\u0434\u0443\u043d\u0430\u0440\u043e\u0434\u043d\u044b\u0445 \u043c\u043e\u0434\u0443\u043b\u0435\u0439\", emba_extractor.get_intern_modules_csi()\n        )\n    )\n    figs.append(\n        _create_boxplot(\"\u041e\u0446\u0435\u043d\u043a\u0430 \u0440\u0430\u0431\u043e\u0442\u044b \u043a\u043e\u043c\u0430\u043d\u0434\u044b \u043a\u0443\u0440\u0441\u0430\", emba_extractor.get_support_csi())\n    )\n    figs.append(\n        _create_boxplot(\"\u041e\u0446\u0435\u043d\u043a\u0430 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0430 \u0433\u0440\u0443\u043f\u043f\u044b\", emba_extractor.get_group_csi())\n    )\n    barnames, values, colors = emba_extractor.get_industry_nps()\n    figs.append(_create_nps(\"NPS EMBA-35 vs NPS \u0438\u043d\u0434\u0443\u0441\u0442\u0440\u0438\u0438\", barnames, values, colors))\n    barnames, values, colors = emba_extractor.get_programs_nps()\n    figs.append(\n        _create_nps(\"\u0421\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 NPS \u0440\u0430\u0437\u043d\u044b\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c \u0428\u043a\u043e\u043b\u044b\", barnames, values, colors)\n    )\n    figs.append(\n        _create_stacked_bar(\"\u0420\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043e\u0446\u0435\u043d\u043e\u043a PILOs\", emba_extractor.get_pilos())\n    )\n    figs.append(\n        _create_hbar(\n            \"\u041b\u0443\u0447\u0448\u0438\u0435 \u043f\u0440\u0435\u043f\u043e\u0434\u0430\u0432\u0430\u0442\u0435\u043b\u0438\",\n            emba_extractor.get_top_lectors(),\n            x_axs_title=\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0433\u043e\u043b\u043e\u0441\u043e\u0432\",\n            y_axs_title=\"\u041f\u0440\u0435\u043f\u043e\u0434\u0430\u0432\u0430\u0442\u0435\u043b\u044c\",\n        )\n    )\n    figs.append(\n        _create_hbar(\n            \"\u0412 \u043a\u0430\u043a\u0438\u0445 \u0430\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u044f\u0445 \u0433\u043e\u0442\u043e\u0432\u044b \u0443\u0447\u0430\u0441\u0442\u0432\u043e\u0432\u0430\u0442\u044c \u0432\u044b\u043f\u0443\u0441\u043a\u043d\u0438\u043a\u0438\",\n            emba_extractor.get_collaborators(),\n            x_axs_title=\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0441\u043e\u0433\u043b\u0430\u0441\u0438\u0432\u0448\u0438\u0445\u0441\u044f\",\n            y_axs_title=\"\u0413\u043e\u0442\u043e\u0432 \u0443\u0447\u0430\u0441\u0442\u0432\u043e\u0432\u0430\u0442\u044c \u0432...\",\n        )\n    )\n\n    return figs\n</code></pre>"},{"location":"references/sections/#app.sections.download.generate_docx","title":"<code>generate_docx(emba_extractor)</code>","text":"<p>Generate a DOCX report from all generated plots.</p> <p>Parameters:</p> Name Type Description Default <code>emba_extractor</code> <code>ExitEmbaExtractor</code> <p>Data extractor used to populate figures.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>File path to the saved DOCX report.</p> Source code in <code>src/app/sections/download.py</code> <pre><code>def generate_docx(emba_extractor: ExitEmbaExtractor) -&gt; str:\n    \"\"\"Generate a DOCX report from all generated plots.\n\n    Args:\n        emba_extractor (ExitEmbaExtractor): Data extractor used to populate figures.\n\n    Returns:\n        str: File path to the saved DOCX report.\n    \"\"\"\n    doc = Document()\n    doc.add_heading(\"\u0421\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u043e\u0442\u0447\u0435\u0442 \u043f\u043e EMBA-35\", 0)\n    for plot in create_all_plots(emba_extractor):\n        img_path = save_plot_as_image(plot)\n        doc.add_picture(img_path, width=Inches(5.5))\n        os.remove(img_path)\n\n    # Save document\n    file_path = f\"report_{uuid.uuid4().hex[:6]}.docx\"\n    doc.save(file_path)\n    return file_path\n</code></pre>"},{"location":"references/sections/#app.sections.download.save_plot_as_image","title":"<code>save_plot_as_image(fig)</code>","text":"<p>Save a Plotly figure as a temporary PNG image file.</p> <p>Parameters:</p> Name Type Description Default <code>fig</code> <code>Figure</code> <p>The Plotly figure to save.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to the saved temporary image file.</p> Source code in <code>src/app/sections/download.py</code> <pre><code>def save_plot_as_image(fig: go.Figure) -&gt; str:\n    \"\"\"Save a Plotly figure as a temporary PNG image file.\n\n    Args:\n        fig (go.Figure): The Plotly figure to save.\n\n    Returns:\n        str: Path to the saved temporary image file.\n    \"\"\"\n    tmpfile = tempfile.NamedTemporaryFile(delete=False, suffix=\".png\")\n    tmpfile.close()\n    pio.write_image(fig, tmpfile.name, format=\"png\", width=800, height=600)\n    return tmpfile.name\n</code></pre>"},{"location":"references/sections/#app.sections.grades_analysis","title":"<code>app.sections.grades_analysis</code>","text":""},{"location":"references/sections/#app.sections.grades_analysis.render","title":"<code>render(emba_extractor)</code>","text":"<p>Render boxplot visualizations and CSI summary using Streamlit.</p> <p>Displays: - Customer Satisfaction Index (CSI) for the program. - Boxplots for various components of the educational experience.</p> <p>Parameters:</p> Name Type Description Default <code>emba_extractor</code> <code>ExitEmbaExtractor</code> <p>Data extractor providing CSI-related survey results.</p> required Source code in <code>src/app/sections/grades_analysis.py</code> <pre><code>def render(emba_extractor: ExitEmbaExtractor) -&gt; None:\n    \"\"\"Render boxplot visualizations and CSI summary using Streamlit.\n\n    Displays:\n    - Customer Satisfaction Index (CSI) for the program.\n    - Boxplots for various components of the educational experience.\n\n    Args:\n        emba_extractor (ExitEmbaExtractor): Data extractor providing CSI-related survey results.\n    \"\"\"\n    st.header(\"\u0410\u043d\u0430\u043b\u0438\u0437 \u043e\u0446\u0435\u043d\u043e\u043a\")\n\n    def _render_boxplot(title: str, data: Union[pd.Series, pd.DataFrame]) -&gt; None:\n        \"\"\"Render a boxplot inside a collapsible Streamlit expander.\n\n        Args:\n            title (str): Title for the plot and expander section.\n            data (Union[pd.Series, pd.DataFrame]): DataFrame or Series used for boxplot generation.\n        \"\"\"\n        fig = PlotGenerator.make_boxplot(data=data, title=title)\n        with st.expander(title):\n            st.plotly_chart(fig, use_container_width=True)\n\n    overall_csi = emba_extractor.get_overall_csi()\n    csi = emba_extractor.calulate_csi(overall_csi)\n    st.markdown(f\"#### \u041e\u0431\u0449\u0435\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 CSI* \u0434\u043b\u044f \u0432\u0441\u0435\u0439 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b: {csi:.2}/10\")\n    st.markdown(\n        \"\\* CSI (Customer Satisfaction Index) - \u043c\u0435\u0442\u0440\u0438\u043a\u0430, \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0449\u0430\u044f \u043d\u0430\u0441\u043a\u043e\u043b\u044c\u043a\u043e\\\n        \u043a\u043b\u0438\u0435\u043d\u0442\u044b \u0443\u0434\u043e\u0432\u043b\u0435\u0442\u0432\u043e\u0440\u0435\u043d\u044b \u043f\u0440\u043e\u0434\u0443\u043a\u0442\u043e\u043c.\"\n    )\n\n    _render_boxplot(\"\u041e\u0446\u0435\u043d\u043a\u0430 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b \u0432 \u0446\u0435\u043b\u043e\u043c\", emba_extractor.get_basic_csi())\n    _render_boxplot(\"\u0420\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043e\u0446\u0435\u043d\u043e\u043a \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0445 \u0441\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u044e\u0449\u0438\u0445 \u043a\u0443\u0440\u0441\u0430\", overall_csi)\n    _render_boxplot(\"\u041e\u0446\u0435\u043d\u043a\u0430 \u0434\u0438\u0437\u0430\u0439\u043d\u0430 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b\", emba_extractor.get_design_csi())\n    _render_boxplot(\n        \"\u041e\u0446\u0435\u043d\u043a\u0430 \u043c\u0435\u0436\u0434\u0443\u043d\u0430\u0440\u043e\u0434\u043d\u044b\u0445 \u043c\u043e\u0434\u0443\u043b\u0435\u0439\", emba_extractor.get_intern_modules_csi()\n    )\n    _render_boxplot(\"\u041e\u0446\u0435\u043d\u043a\u0430 \u0440\u0430\u0431\u043e\u0442\u044b \u043a\u043e\u043c\u0430\u043d\u0434\u044b \u043a\u0443\u0440\u0441\u0430\", emba_extractor.get_support_csi())\n    _render_boxplot(\"\u041e\u0446\u0435\u043d\u043a\u0430 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0430 \u0433\u0440\u0443\u043f\u043f\u044b\", emba_extractor.get_group_csi())\n    _render_boxplot(\"\u041e\u0446\u0435\u043d\u043a\u0430 \u0440\u0430\u0431\u043e\u0442\u044b \u043a\u043e\u043c\u0430\u043d\u0434\u044b \u043a\u0443\u0440\u0441\u0430\", emba_extractor.get_support_csi())\n    _render_boxplot(\"\u041e\u0446\u0435\u043d\u043a\u0430 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0430 \u0433\u0440\u0443\u043f\u043f\u044b\", emba_extractor.get_group_csi())\n</code></pre>"},{"location":"references/sections/#app.sections.nps","title":"<code>app.sections.nps</code>","text":""},{"location":"references/sections/#app.sections.nps.render","title":"<code>render(emba_extractor)</code>","text":"<p>Render Net Promoter Score (NPS) bar plots using Streamlit and Plotly.</p> <p>Displays NPS comparisons: - Between EMBA-35 and other industries. - Across various programs at the institution.</p> <p>Parameters:</p> Name Type Description Default <code>emba_extractor</code> <code>ExitEmbaExtractor</code> <p>Extractor object providing NPS-related data.</p> required Source code in <code>src/app/sections/nps.py</code> <pre><code>def render(emba_extractor: ExitEmbaExtractor) -&gt; None:\n    \"\"\"Render Net Promoter Score (NPS) bar plots using Streamlit and Plotly.\n\n    Displays NPS comparisons:\n    - Between EMBA-35 and other industries.\n    - Across various programs at the institution.\n\n    Args:\n        emba_extractor (ExitEmbaExtractor): Extractor object providing NPS-related data.\n    \"\"\"\n    st.header(\"NPS\")\n\n    def _render_nps(\n        title: str,\n        barnames: List[str],\n        values: List[int],\n        colors: List[str],\n    ) -&gt; None:\n        \"\"\"Render an NPS bar plot inside a collapsible Streamlit expander.\n\n        Args:\n            title (str): Title of the plot and expander section.\n            barnames (List[str]): Labels for each bar.\n            values (List[int]): Numerical values for each group.\n            colors (List[str]): Bar colors corresponding to NPS categories.\n        \"\"\"\n        fig = PlotGenerator.make_nps_barplot(\n            barnames=barnames, values=values, colors=colors, title=title\n        )\n        with st.expander(title):\n            st.plotly_chart(fig, use_container_width=True)\n\n    st.markdown(\n        \"NPS (Net Promoter Score) - \u0438\u043d\u0434\u0435\u043a\u0441 \u043f\u043e\u0442\u0440\u0435\u0431\u0438\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0439 \u043b\u043e\u044f\u043b\u044c\u043d\u043e\u0441\u0442\u0438, \\\n        \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0449\u0438\u0439 \u043d\u0430\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043a\u043b\u0438\u0435\u043d\u0442\u044b \u0434\u043e\u0432\u043e\u043b\u044c\u043d\u044b \u043a\u043e\u043c\u043f\u0430\u043d\u0438\u0435\u0439 \u0438 \u0433\u043e\u0442\u043e\u0432\u044b \u0440\u0435\u043a\u043e\u043c\u0435\u043d\u0434\u043e\u0432\u0430\u0442\u044c \u0435\u0435 \u0443\u0441\u043b\u0443\u0433\u0438.\"\n    )\n\n    barnames, values, colors = emba_extractor.get_industry_nps()\n    _render_nps(\"NPS EMBA-35 vs NPS \u0438\u043d\u0434\u0443\u0441\u0442\u0440\u0438\u0438\", barnames, values, colors)\n    barnames, values, colors = emba_extractor.get_programs_nps()\n    _render_nps(\"\u0421\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 NPS \u0440\u0430\u0437\u043d\u044b\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c \u0428\u043a\u043e\u043b\u044b\", barnames, values, colors)\n    barnames, values, colors = emba_extractor.get_programs_nps()\n    _render_nps(\"\u0421\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 NPS \u0440\u0430\u0437\u043d\u044b\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c \u0428\u043a\u043e\u043b\u044b\", barnames, values, colors)\n</code></pre>"},{"location":"references/sections/#app.sections.other","title":"<code>app.sections.other</code>","text":""},{"location":"references/sections/#app.sections.other.render","title":"<code>render(emba_extractor)</code>","text":"<p>Render horizontal bar charts for additional survey insights using Streamlit.</p> <p>Displays: - Top-voted lecturers. - Areas where alumni are willing to collaborate.</p> <p>Parameters:</p> Name Type Description Default <code>emba_extractor</code> <code>ExitEmbaExtractor</code> <p>Extractor providing survey-derived insights.</p> required Source code in <code>src/app/sections/other.py</code> <pre><code>def render(emba_extractor: ExitEmbaExtractor) -&gt; None:\n    \"\"\"Render horizontal bar charts for additional survey insights using Streamlit.\n\n    Displays:\n    - Top-voted lecturers.\n    - Areas where alumni are willing to collaborate.\n\n    Args:\n        emba_extractor (ExitEmbaExtractor): Extractor providing survey-derived insights.\n    \"\"\"\n    st.header(\"\u041f\u0440\u043e\u0447\u0435\u0435\")\n\n    def _render_hbar(\n        title: str,\n        data: Union[pd.Series, pd.DataFrame],\n        x_axs_title: str,\n        y_axs_title: str,\n    ) -&gt; None:\n        \"\"\"Render a horizontal bar chart inside a collapsible Streamlit expander.\n\n        Args:\n            title (str): Title of the plot and expander.\n            data (Union[pd.Series, pd.DataFrame]): Data to plot; typically a Series of counts.\n            x_axs_title (str): Label for the x-axis.\n            y_axs_title (str): Label for the y-axis.\n        \"\"\"\n        fig = PlotGenerator.make_hbarplot(\n            score_counts=data,\n            title=title,\n            x_axs_title=x_axs_title,\n            y_axs_title=y_axs_title,\n        )\n        with st.expander(title):\n            st.plotly_chart(fig, use_container_width=True)\n\n    _render_hbar(\n        \"\u041b\u0443\u0447\u0448\u0438\u0435 \u043f\u0440\u0435\u043f\u043e\u0434\u0430\u0432\u0430\u0442\u0435\u043b\u0438\",\n        emba_extractor.get_top_lectors(),\n        x_axs_title=\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0433\u043e\u043b\u043e\u0441\u043e\u0432\",\n        y_axs_title=\"\u041f\u0440\u0435\u043f\u043e\u0434\u0430\u0432\u0430\u0442\u0435\u043b\u044c\",\n    )\n    _render_hbar(\n        \"\u0412 \u043a\u0430\u043a\u0438\u0445 \u0430\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u044f\u0445 \u0433\u043e\u0442\u043e\u0432\u044b \u0443\u0447\u0430\u0441\u0442\u0432\u043e\u0432\u0430\u0442\u044c \u0432\u044b\u043f\u0443\u0441\u043a\u043d\u0438\u043a\u0438\",\n        emba_extractor.get_collaborators(),\n        x_axs_title=\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0441\u043e\u0433\u043b\u0430\u0441\u0438\u0432\u0448\u0438\u0445\u0441\u044f\",\n        y_axs_title=\"\u0413\u043e\u0442\u043e\u0432 \u0443\u0447\u0430\u0441\u0442\u0432\u043e\u0432\u0430\u0442\u044c \u0432...\",\n    )\n</code></pre>"},{"location":"references/sections/#app.sections.pilos","title":"<code>app.sections.pilos</code>","text":""},{"location":"references/sections/#app.sections.pilos.render","title":"<code>render(emba_extractor)</code>","text":"<p>Render PILOs score distributions using Streamlit and Plotly visualizations.</p> <p>Displays a header and description, then renders a collapsible stacked barplot showing the distribution of student scores on Programme Intended Learning Outcomes (PILOs).</p> <p>Parameters:</p> Name Type Description Default <code>emba_extractor</code> <code>ExitEmbaExtractor</code> <p>An object with a <code>get_pilos()</code> method returning a DataFrame             suitable for <code>PlotGenerator.make_stacked_barplot</code></p> required Source code in <code>src/app/sections/pilos.py</code> <pre><code>def render(emba_extractor: ExitEmbaExtractor) -&gt; None:\n    \"\"\"Render PILOs score distributions using Streamlit and Plotly visualizations.\n\n    Displays a header and description, then renders a collapsible stacked barplot\n    showing the distribution of student scores on Programme Intended Learning Outcomes (PILOs).\n\n    Args:\n        emba_extractor (ExitEmbaExtractor): An object with a `get_pilos()` method returning a DataFrame\n                        suitable for `PlotGenerator.make_stacked_barplot`\n    \"\"\"\n    st.header(\"\u0420\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043e\u0446\u0435\u043d\u043e\u043a PILOs\")\n    st.markdown(\n        \"PILOs (Programme Intended Learning Outcomes) - \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u043f\u0440\u0435\u0434\u043f\u043e\u043b\u0430\u0433\u0430\u0435\u043c\u044b\u0445 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432 \u043e\u0431\u0443\u0447\u0435\u043d\u0438\u044f.\"\n    )\n\n    def _render_stacked_bar(title: str, data: pd.DataFrame) -&gt; None:\n        \"\"\"Render a single stacked bar chart in a collapsible expander.\n\n        Args:\n            title (str): The title for both the chart and the expander section.\n            data (pd.DataFrame): A DataFrame where rows represent categories (e.g., subjects)\n            and columns represent score counts to be visualized.\n        \"\"\"\n        fig = PlotGenerator.make_stacked_barplot(\n            score_counts=data,\n            title=title,\n            x_axs_title=\"\u041f\u0440\u0435\u0434\u043c\u0435\u0442\",\n            y_axs_title=\"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0441\u0442\u0443\u0434\u0435\u043d\u0442\u043e\u0432\",\n        )\n        with st.expander(title):\n            st.plotly_chart(fig, use_container_width=True)\n\n    _render_stacked_bar(\"\u0420\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043e\u0446\u0435\u043d\u043e\u043a PILOs\", emba_extractor.get_pilos())\n    _render_stacked_bar(\"\u0420\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043e\u0446\u0435\u043d\u043e\u043a PILOs\", emba_extractor.get_pilos())\n</code></pre>"}]}